<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE book [
<!ENTITY % BOOK_ENTITIES SYSTEM "QluMan_Guide.ent">
%BOOK_ENTITIES;
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "/usr/share/xml/docbook/schema/dtd/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude">

  <xi:include href="Book_Info.xml"/>
  <xi:include href="Preface.xml"/>
  <xi:include href="Introduction.xml"/>

  <chapter xml:id="chap-Starting-Up">
    <title>Starting Up</title>
    <section xml:id="sec-logging-in">
      <title>Logging in</title>
      <para>
	<!--cbox(connect_cluster_dialog__enter_password_safe.png)-->
	<!--cbox(connect_cluster_dialog__enter_password_safe_remember.png)-->
	When starting <application>qluman-qt</application>, it asks for the password to your
	certificate safe.  The certificate safe contains the login informations for your
	clusters and private keys for each account. The password for the certificate safe is
	required on every start and whenever changes to the safe need to be safed. You can have
	the client remember the password for the duration it is running by checking the
	<classname>Remember password</classname> checkbox. If you are starting
	<application>qluman-qt</application> for the first time and therefore have no
	certificate safe yet this dialog is skipped and an empty <classname>Connect
	Cluster</classname> dialog opens directly. See <xref linkend="manage-cluster-dialog"/>
	below to add your cluster.
      </para>
      <para>
	<!--cbox(connect_cluster_dialog.png)-->
	<!--cbox(connect_cluster_dialog__select_cluster.png)-->
	Having entered the correct password for the certificate safe the <classname>Connect
	Cluster</classname> dialog opens. The last cluster used will be pre selectedor a
	different cluster can be selected from the drop-down menu. Click the
	<guibutton>Connect</guibutton> button to connect to the selected cluster.
	<!--cbox(first_steps__saving_key.png)-->
	If this is the first time you connect to the cluster then at this point the client
	generates a random public and private key pair for use with this cluster and user. It
	then connect to the server using those keys and authenticates itself using the one-time
	token. On success the server stores the public key of the client for future logins and
	the client stores both the private and public keys in the certificate safe finalizing
	the initial handshake.
	<note>
	  <para>
	    The GUI client asks for the password for the certificate safe to store the
	    generated public/private key pair. It will only do this when you connect with a
	    one-time token. The next time the saved key pair will be used to connect and
	    authenticate and the safe contents are not changed.
	  </para>
	</note>
      </para>
    </section>
    <section xml:id="manage-cluster-dialog">
      <title>Managing Clusters</title>
      <para>
	<!--cbox(first_steps__connect_cluster_1.png)-->
	<!--cbox(manage_clusters_idalog.png)-->	
	The <classname>Manage Clusters</classname> dialog manages all your acounts on different
	clusters or as different users. It allows adding new cluster acounts, editing existing
	acounts or removing obsolete acounts as well as changing the password for the
	certificate safe. It can be opened by clicking <guibutton>Edit</guibutton> in the
	<classname>Connect Cluster</classname> dialog.
      </para>
      <bridgehead>
	Adding a new Cluster
      </bridgehead>
      <para>
	<!--cbox(first_steps__manage_clusters_new.png)-->
	To add a new cluster click the <guibutton>New</guibutton> button and select
	<guibutton>New Cluster (paste)</guibutton> or <guibutton>New Cluster (file)</guibutton>
	from the menu depending on whether you want to paste the one-time token or load it from
	a file. If you don't have a ont-time token for the cluster see <xref
	linkend="one-time-token"/>.
      </para>
      <para>
	<!--cbox(first_steps__new_cluster__paste_1.png)-->
	<!--cbox(first_steps__new_cluster__file_1.png)-->
	<!--cbox(first_steps__new_cluster__2.png)-->
	<!--cbox(first_steps__new_cluster__3.png)-->
	Paste the one-time token data into the dialog and click <guibutton>Decrypt</guibutton>
	or select the file for the token. When asked for the password enter the pin you used
	when creating the token. The dialog should then show the server infos that where
	included with the one-time token. If you started <application>qluman-qt</application>
	on your workstation then you might have to change the <parameter>Local
	Hostname</parameter> to use the external name of the head-node. Similarly if you
	changed the port for qlumand you have to adjust that too. The
	<parameter>Alias</parameter> is the name the cluster will use in the drop-down menu in
	the <classname>Connect Cluster</classname> dialog. Click <guibutton>Ok</guibutton> to
	add the cluster connection.
      </para>
      <para>
	<!--cbox(first_steps__manage_clusters_save.png)-->
	<!--cbox(first_steps__manage_clusters_password.png)-->
	<!--cbox(first_steps__manage_clusters_confirm.png)-->
	After adding the new cluster select <guibutton>Save</guibutton> to save the changes. If
	this is your first cluster then it will create the certificate safe and ask you to
	enter and confirm a password. Otherwise it will ask for the existing password unless
	the <guibutton>Remember password</guibutton> checkbox was enabled.
      </para>
      <bridgehead>
	Sorting multiple clusters
      </bridgehead>
      <para>
	<!--cbox(manage_clusters_dialog.png)-->
	<!--cbox(manage_clusters_dialog__new_menu__group.png)-->
	<!--cbox(manage_clusters_dialog__group.png)-->
	<!--cbox(manage_clusters_dialog__group2.png)-->
	<!--cbox(connect_cluster_dialog__select_cluster_group.png)-->
	When dealing with multiple clusters the clusters can be reordered using drag&amp;drop
	to move them to the desired location in the list. Clusters can also be grouped together
	by first creating a new group and then dragging the cluster into the group. The tree
	structure in the <classname>Manage Clusters</classname> dialog will be reflected in the
	drop-down menu in the <classname>Connect Cluster</classname> dialog. This allows even
	large installations with multiple cluster to remain managable for the admin. Normal
	users will most likely not need this feature.
      </para>
      <bridgehead>
	Changing the certificate safe password
      </bridgehead>
      <para>
	<!--cbox(manage_clusters_dialog__changing_password.png)-->
	<!--cbox(manage_clusters_dialog__change_password.png)-->
	<!--cbox(manage_clusters_dialog__change_password_mismatch.png)-->
	The <classname>Manage Clusters</classname> dialog allows changing the password for the
	certificate safe. This requires entering the old password for the safe as well as the
	new password and a confirmation of the new password. The <guibutton>Ok</guibutton>
	button will only be selectable if the new password and confirmation matches.
      </para>
    </section>
    <section xml:id="license-installation">
      <title>License Installation</title>
      <para>
	<!--cbox(menu-license_key.png)-->
	<!--cbox(expired.png)-->
	To be able to configure your cluster with <application>QluMan</application>, a license
	key needs to be installed. Without a valid key, an error will be displayed upon
	start-up and the QluMan daemon will only allow read-only operations. In read-only mode,
	you can have a look at all the settings, but you can't change anything.
      </para>
      <para>
	After closing the error dialog the License Key window can be opened by selecting
	<guimenuitem>File</guimenuitem>-><guimenuitem>License Key</guimenuitem> in the main
	Menu. If you never installed a license key before, the window will come up mostly
	empty.
      </para>
      <para>
	<!--cbox(license_key-request.png)-->
	<!--cbox(license_key__key_info.png)-->
	<!--cbox(license_key__empty.png)-->
	To request a license key, click the <guibutton>Request Key</guibutton> button and a
	<classname>Key Info Dialog</classname> will open asking you for your name and address
	info. If you intend to use <classname>Qlustar Basic Edition</classname>, checkmark
	<guibutton>Free / non-profit license</guibutton> at the bottom of the dialog. Select
	<guibutton>OK</guibutton> to continue saving the key request in a file. Enter a
	file-name and save. You will now have to send an e-mail specifying the required number
	of nodes and features (see <link xlink:href="http://qlustar.com/order/___blank___">our
	order page</link>) with this key file attached to <link
	xlink:href="mailto:order@q-leap.com?Subject=License%20request">order@q-leap.com</link>
      </para>
      <para>
	<!--cbox(license_key.png)-->
	After a while, you will receive a license key by mail that you can import using the
	<guibutton>Import Key</guibutton> button. If the import was successful, the license
	information will be displayed and you're ready to start working with
	<application>QluMan</application>.
      </para>
      <para>
	After a successful license installation, you can move on to the interesting stuff. Upon
	start-up, the QluMan client automatically connects to the local QluMan daemon and opens
	the <classname>Enclosure View</classname> window.
      </para>
    </section>
    <section xml:id="Configuring-the-Network">
      <title>Configuring Network Parameters</title>
      <para>
	<!--cbox(main_window__network_config.png)-->
	During the installation of Qlustar, the configuration parameters for the cluster
	network had to be entered and normally you won't need to change them. For the rare
	circumstances, where they do need to be changed, or in case you just want to verify the
	settings, you can select <guibutton>Manage Cluster</guibutton>-><guibutton>Network
	Config</guibutton> from the main windows menu.
      </para>
      <note>
	<para>
	Note, that changing anything in this dialog involves a fundamental reconfiguration of
	the cluster setup, including rebooting the whole cluster. For this reason, changes in
	the <classname>Global Cluster Network Config</classname> do not take effect immediately
	after being changed in the dialog. They require a further confirmation by clicking the
	<guibutton>Save</guibutton> button, that will then actually commit the changes.
	</para>
      </note>
      <bridgehead>
	Configuring Ethernet
      </bridgehead>
      <para>
	<!--cbox(network_config__ethernet.png)-->
	Changing the Ethernet network configuration is the most involved and requires several
	steps. In the <classname>Global Cluster Network Config</classname> there are 3 settings
	relevant for <firstterm>Ethernet</firstterm>: The Cluster Network IP address, the
	netmask and the cluster internal Head IP address. When changing the Cluster Network IP
	address or netmask, the IP addresses of all hosts configured in QluMan will be remapped
	to reflect their new values. This requires that the new netmask is large enough, so
	that the resulting network range can include all existing hosts in the
	cluster. Therefore, the GUI won't let you pick anything too small. If there are unused
	address ranges in your existing network and you need a smaller netmask than currently
	selectable, you will first have to change some host addresses so that all of them
	combined occupy a small enough subset of the current network.
      </para>
      <para>
	Changing the network address IP will automatically remap the cluster internal Head IP
	address as well, while changing the netmask will not. Note, that the Qlustar
	convention, to use the second last IP of the cluster network as the Head IP, is
	obviously not a requirement. Hence, this is not done automatically when changing the
	netmask. Furthermore, changing the Head IP involves some additional steps without which
	the nodes in the cluster won't function or even boot. The point is that the Head IP
	also appears in the <classname>Global DHCP Template</classname>, NIS Host header and
	SSH Hosts / Known Hosts. These templates are simple, freely editable text blobs. A
	change of the Head IP in the <classname>Global Cluster Network Config</classname> will
	not change them, so you need to check and adjust each of them manually.
      </para>
      <para>
	<!--cbox(network_config__proxy.png)-->
	If the head-node does not have direct access to the Internet, a <parameter>http
	proxy</parameter> must be configured. Qluman uses this proxy to download packages from
	the <guilabel>Qlustar repository</guilabel>, when creating a new chroot. Click the
	checkmark before <guilabel>Http Proxy</guilabel> to enable proxy support and enter the
	hostname together with the port of the proxy. If the proxy requires authentication,
	click the checkmark before <guilabel>Authenticate</guilabel> and enter a username and
	password. Like usual, the new settings will only take affect, when you click the
	<guibutton>Save</guibutton> button.
      </para>
    </section>
    <section xml:id="EnclosureView">
      <title>Enclosure View</title>
      <para>
	<!--cbox(startup.png)-->
	The <classname>Enclosure View</classname> shows an overview of the cluster in a tree
	structure.  The tree structure is designed to reflect the physical structure of the
	cluster. At the lowest level are the hosts. A host can be a head, storage or compute
	node but also a switch e.g. In general, anything in the cluster that has a name, IP and
	MAC address is a host. A host is represented by its <literal>bare board</literal> and
	should be placed into a <firstterm> host enclosure</firstterm>. 1U, 2U, 3U or 4U
	enclosures contain exactly one board, while others like a Twin or Blade chassis can
	have multiple boards. Once defined, host enclosures can be placed into
	<firstterm>racks</firstterm>, racks grouped into rows, rows into rooms and so on. The
	tree has a simple drag&amp;drop interface. E.g. you can select a number of nodes (by
	holding the <keycap>CTRL</keycap> key and clicking or holding the <keycap>shift
	key</keycap> and dragging the mouse) and drag&amp;drop them into a <firstterm>Blade
	enclosure</firstterm>.
      </para>
      <para>
	<!--cbox(enclosure_view__select_host.png)-->
	Selecting a node in the tree displays its configuration info on the right hand side:
	The hostname, IP and MAC can be edited and saved by pressing
	<keycap>return</keycap>. The check-mark to the right of the field shows the state of
	the change. If the entered value is not valid, the check-box is cleared
	<!--cbox(checkbox_unchecked.png)-->
	The check-boxes tool-tip (you'll see it when the mouse moves on top of it) gives the
	reason why the entered value is invalid. If the entered value is valid but has not yet
	been saved, the check-box is checked but ghosted
	<!--cbox(checkbox_ghostchecked.png)-->
	Finally, after the value has been saved in the database, the check-box shows a solid
	check.
	<!--cbox(checkbox_checked.png)-->
      </para>
      <para>
	For nodes that are not part of a <literal>multi-host enclosure</literal> (like a Blade
	or Twin chassis) the enclosure type can be changed to one of the single-slot host
	enclosures (1U, 2U, etc.). A new enclosure of the chosen type will then be created if
	the node is not already part of one. If a node is included in a multi-host enclosure,
	this field will be ghosted.
      </para>
      <para>
	The template field allows to select a so-called <literal> Host Template</literal> for
	the node. Host Templates are a collection of exactly one <xref
	linkend="Generic-Properties" endterm="Generic-Properties"/>, <xref
	linkend="Hardware-Properties" endterm="Hardware-Properties"/> and <xref
	linkend="Config-Classes"/>.  Usually large groups of nodes have identical hardware and
	software configuration and will use the same template. Deviations from the template can
	be set for individual hosts by direct assignment of either a property set or individual
	property directly to the host. In case of unique properties direct assignment override
	settings from the template (or property set), for non-unique properties this is
	additive.
	<note>
	  <para>
	    Any changes made in the configuration only affects the active node (as indicated by
	    the hostname in the info part of the enclosure view), and not all selected
	    nodes. Configurations for all selected nodes can be made by using the context menu
	    (right click) in the tree view.
	  </para>
	</note>
      </para>
      <bridgehead>
	Enclosures
      </bridgehead>
      <para>
	<!--cbox(enclosure_view__select_twin2.png)-->
	Similar to host nodes, selecting an enclosure entry displays the physical layout of the
	corresponding enclosure on the right. Controls to select the visibility level and
	special slots are available at the top of the display. See below for more details about
	these. The name of the enclosure and its type (in brackets) is shown in the title. In
	the above case, both name and type are "Twin². Below the title you have a
	representation of the physical layout of the enclosure. For this example, you see the
	2x2 slots that are characteristic of a
	<!--cbox(enclosure_view__select_rack_specials.png)-->
	Twin² enclosure. Two slots are filled with <systemitem
	class="systemname">beo-01</systemitem> and <systemitem
	class="systemname">beo-02</systemitem> and two slots remain empty, showing only the
	number of each slot in brackets.
      </para>
      <para>
	Selecting a rack shows a more complex picture. The current example rack holds ten
	enclosures in its central 19 inch slots: A FatTwin, a Twin, a Twin², a Blade 1, 3 Blade
	2, another Twin² and two 1U enclosures containing <systemitem
	class="systemname">beo-11</systemitem> and <systemitem
	class="systemname">beo-12</systemitem>. The special top, left, right and bottom (not
	visible) slots are empty. In future versions a network switch or power controller, that
	is mounted at some special position of the rack, can be placed into these special
	slots.
      </para>
      <para>
	<!--cbox(enclosure_view__select_rack_deep.png)-->
	<!--cbox(enclosure_view__select_rack.png)-->
	Now let's explain the effect of the two controls at the top in more detail: The
	<guibutton>Show special slots</guibutton> check-box controls the visibility of the top,
	left, right and bottom special slots. Especially if these slots are empty, this will
	provide a more compact view of the interesting central slots. The other control, the
	visibility level, controls how many levels of the enclosure hierarchy are shown:
	Selecting a depth of 2 shows not only the selected rack with its slots but also the
	contents of the enclosures in each slot. Since the current version of
	<application>QluMan</application> only supports host enclosures (Twin, Blade, ...) and
	racks, a depth larger than 2 has no effect yet. In future versions, it will be possible
	to group racks into rows, rows into rooms, rooms into buildings and so on. This will
	allow you to reflect the physical layout of your cluster in as much detail as you like.
      </para>
      <blockquote>
	<bridgehead>
	  Populating Enclosures
	</bridgehead>
	<para>
	  New enclosures can be added through the context menu. The new enclosure must be given
	  a name and its type can be selected. Currently, enclosure types cannot be manipulated
	  yet. This will change in a future version.
	</para>
	<para>
	  <!--cbox(enclosure_view__new_enclosure2.png)-->
	  <!--cbox(enclosure_view__new_enclosure.png)-->
	  Suitable for ordinary servers, a host being selected in the enclosure view can be
	  placed into a single slot host enclosure directly by selecting the correct type in
	  the host info part of the window (see <xref linkend="EnclosureView"/>). For host
	  enclosures that can hold more than one server/node (twin servers, blades etc.),
	  drag&amp;drop may be used to move hosts into them. Moreover, it's also possible to
	  create larger (non-host) enclosures (like racks) and move host enclosures into them
	  also by using using drag&amp;drop. Note that a bare host cannot be placed directly
	  into a non-host enclosure, only if it is already inside a host enclosure.
	</para>
	<para>
	  <!--cbox(enclosure_view__select_host_enclosure2.png)-->
	  <!--cbox(enclosure_view__select_host_enclosure.png)-->
	  Another option to place hosts into enclosures is by selecting a number of them and
	  then choosing a host enclosure from the context menu. This way, a new enclosure of
	  the selected type is automatically created and all selected hosts are moved into
	  it. If more hosts than can fit into a single enclosure of the chosen type are
	  selected, additional enclosures of the same type will be created such that all hosts
	  can be placed into one of them. This makes it easy to position large numbers of
	  identical hosts into their enclosures. If the selected hosts were in an enclosure
	  before and that enclosure becomes empty and is not itself part of a larger enclosure
	  then the empty enclosure is automatically removed.
	</para>
	<para>
	  Relocating hosts by selecting a different host enclosure is supported not only on
	  directly selected hosts but also on hosts inside selected enclosures. This allows
	  changing the type of enclosure a group of hosts is in by selecting the old
	  enclosure(s) and choosing a new one from the context menu. Note that this procedure
	  does not change the type of the old enclosure but rather creates a new one, moves all
	  the hosts to it and then deletes the now empty old enclosure(s). Try it out: Place a
	  number of hosts into a large enclosure (like a blade), then select the enclosure and
	  choose a small enclosure (like 1U) to relocate them. In general, such an operation
	  will create one enclosure of the new type and fill all its slots before creating a
	  second one. Hosts that where in different enclosures before can end up in the same
	  enclosure after and hosts that were in the same enclosure before can end up in
	  different enclosures after the operation.
	</para>
	<para>
	  <!--cbox(enclosure_view__move_to_slot.png)-->
	  <!--cbox(enclosure_view__select_host_enclosure3.png)-->
	  When using drag&amp;drop for the relocation, the host or enclosure is always placed
	  into the lowest suitable slot of the target enclosure. This reflects our experience,
	  that usually enclosures are simply filled from left to right and bottom to top. But
	  sometimes this is not the case and a host or enclosure should be in a different slot
	  as compared to the automatic placement. In this case, the host or enclosure can be
	  moved through the context menu. The latter shows all the free slots the host or
	  enclosure can be relocated to and a checked mark indicates the current location. Of
	  course the relocation is only allowed into free slots. Hence, it may require removing
	  (drag&amp;drop out of the enclosure) a host or enclosure temporarily to free space
	  for moving things around.
	</para>
      </blockquote>
      <bridgehead xml:id="Selection">
	Selection
      </bridgehead>
      <para>
	There are situations where one wants to change a property or config of a set of
	hosts. For example, you may want to change all nodes located in a particular blade to
	no longer format their disk on boot. This can be achieved by selecting a set of host in
	the enclosure view with the mouse. A range of hosts can be selected by clicking on the
	first host and then clicking on the last host while pressing the shift key. Hosts can
	also be added or removed from the selection by clicking on a host while pressing the
	<keycap>CTRL</keycap> key. Once a set of hosts is selected, changes can be made to all
	selected hosts through the context menu. For instance, this allows changing the Host
	Template or add/alter a generic property of a set of hosts.
      </para>
      <para>
	<!--cbox(enclosure_view__selection_button.png)-->
	<!--cbox(enclosure_view__selection__menu.png)-->
	<!--cbox(enclosure_view__selection__submenu.png)-->
	An alternative and more powerful way to select a set of hosts is available via the
	<guibutton>Selection</guibutton> button at the bottom of the <classname>Enclosure
	View</classname>. At the top of the selection menu this brings up you'll find 3 items
	to select all hosts, clear the selection or to invert the selection. Below these items
	is a list of filters by which subsets of hosts were defined according to specific
	criteria. For more details on how to construct such host filters see <xref
	linkend="HostFilterEditor"/>. When pressing <guibutton>Select</guibutton>, the
	selection is set to the hosts defined by the corresponding filter, dropping any
	previously selected hosts. <guibutton>Add to</guibutton>> adds, while <guibutton>Remove
	from</guibutton> removes the hosts defined by the filter from the current
	selection. <guibutton>Intersection</guibutton> sets the selection to only those hosts
	in the current selection, that are also part of the set defined by the filter.
      </para>
    </section>
    <section xml:id="New-Hosts">
      <title>New Hosts</title>
      <para>
	To add new hosts to the cluster you can either select "New Hosts" from the context menu
	in the Enclosure View tree or from the "Manage Hosts" menu. This opens the "Hosts
	Window".
	<!--cbox(new_host_window.png)-->
      </para>
      <para>
	 Adding a new host requires the specification of an IP address, hostname and MAC in the
	 corresponding three text fields of the dialog. The entered values are checked for
	 their validity. If one of them is not valid, the check-box to its right remains
	 cleared <!--checkbox_unchecked.png-->.  The tool-tip of the check-box will then show,
	 why it is invalid. If all the values are valid, all check-boxes will show a solid
	 check <!--checkbox_checked.png--> and the <guibutton>Add Host</guibutton> button will
	 become selectable. For convenience and if it makes sense, the IP address and the
	 numeric part of the hostname (if there is one) will automatically be incremented by
	 one, after a host was added. So in most cases, these fields will not have to be
	 changed manually to add the next host. Only the new MAC will need to be entered.
      </para>
      <para>
	<!--cbox(new_host_window-select.png)-->
	To help adding new hosts, qlumand scans the <filename>DHCP log file</filename> for
	unknown hosts that have requested an IP address. For each unknown host found in the
	logs, the table at the top of the window shows the time of the first and last
	appearance in the log, its MAC address as well as the hardware vendor this MAC is
	assigned too (if known). Selecting a MAC in the table copies it into the MAC text field
	at the bottom and a double-click adds the host with the selected MAC. One can also
	select multiple lines (by holding the <keycap>CTRL</keycap> key and clicking or holding
	the <keycap>shift</keycap> key and dragging the mouse) and then click the
	<guibutton>Add Selected</guibutton> button at the bottom to add them all using the
	auto-increment feature for the IP address and hostname. If unsure, try adding a single
	host first and check the auto-increment does the right thing before adding a group of
	hosts. One easy way to add groups of hosts is to power them on one at a time with a
	<!--cbox(new_host_window-template.png)-->
	short delay (say 30 seconds). The hosts will then appear in the Unknown MACs table in
	the order they were powered on and can be added as a group with the click of a single
	button.
      </para>
      <para>
	At the bottom of the window a <xref linkend="Host-Templates" endterm="Host-Templates"/>
	can be selected that will be used as the default for new hosts. Most of the time, no
	additional configuration is needed for a new host.
      </para>
    </section>
    <section xml:id="Configuring-a-Host">
      <title>Configuring a Host</title>
      <para>
	The configuration of a host consists of the definition and assignment of different
	types of properties and config classes. Properties are always a key + value pair and
	are further split into generic, hardware and specific properties.
      </para>
      <bridgehead xml:id="Hardware-Properties">
	Hardware Properties
      </bridgehead>
      <para>
	<literal>Hardware properties</literal> are used to describe the hardware of a
	host. Amongst others, hardware properties like the amount of RAM or number of CPU cores
	are used to configure resource management systems like slurm or torque, so jobs can be
	assigned to the desired hosts. Others, like e.g. the server model or BIOS version, are
	purely informational and might be used for inventory management.
      </para>
      <bridgehead xml:id="Generic-Properties">
	Generic Properties
      </bridgehead>
      <para>
	A property that is not hardware related and not specific to a host is called generic.
	<literal>Generic properties</literal> can be configuration options, like 'OpenSM Host',
	or purely informational, like 'Paid by'. While hardware properties are meant to be more
	rigid typically with a configurable set of fixed values, generic properties are more
	flexible and can be defined at will. This will become more apparent in future versions
	of <application>QluMan</application>. <literal>Generic properties</literal> are also
	not necessarily unique, making it possible to assign multiple values for a single
	generic property. This is useful e.g. to add multiple torque host tags or to put hosts
	in multiple groups for dsh/pdsh (via the 'Host tag').
      </para>
      <bridgehead xml:id="Specific-Properties">
	Specific Properties
      </bridgehead>
      <para>
	As the name suggests, <literal>specific properties</literal> are specific to a single
	host. The best example for such a property is the serial number of the host.
      </para>
      <bridgehead xml:id="PropConf-Sets">
	Property/Config Sets
      </bridgehead>
      <para>
	<!--cbox(enclosure_view__select_template.png)-->
	Individual generic properties, hardware properties and config classes can be used to
	define generic property sets, hardware property sets and config sets. This is simply a
	means of grouping them together so they can be used as a single entity. A <literal>Host
	Template</literal> can then be created by choosing one generic property set, one
	hardware property set and one config set.
      </para>
      <bridgehead xml:id="Host-Templates">
	Host Templates
      </bridgehead>
      <para>
	When a correct <literal>Host Template</literal> exists, a host can be configured by
	selecting the desired template in the <classname>Enclosure View</classname> window.
	For a single host, this can be done by selecting it in the tree view. This brings up
	the host <!--cbox(enclosure_view__select_template2.png)--> information on the left and
	the template can be selected from the drop-down menu. To configure multiple hosts, you
	would select them in the tree view and choose a <literal>Host Template</literal> from
	the context menu. The check-marks in the sub-menu indicate which <literal>Host
	Templates</literal> are currently assigned (if any) for the selected nodes. This action
	will override the previous assignment.
      </para>
      <para>
	<literal>Generic properties</literal> can also be assigned to a host individually. Such
	assigned properties take precedence over ones of the same type selected through the
	<literal>Host Template</literal>. This is useful when a property should be changed
	temporarily for some hosts or when a property should not be
	<!--cbox(enclosure_view__select_generic_property.png)-->
	changeable globally through the Host Template. Note that by default, every new host has
	the generic property <parameter>Schedule Format: always</parameter>, which is required
	to format the disk on the first boot. This should be removed after the first successful
	boot of the host so that log files will be preserved across boots in the future.
      </para>
    </section>
    <section xml:id="Config-Classes">
      <title>Config Classes</title>
      <para>
	<!--cbox(write_files__with_changes.png)-->
	<!--cbox(write_files.png)-->
	Config Classes manage configurations that are too complex to fit into the key + value
	scheme used by properties. Therefore, there is no common interface to configure all
	classes. Instead each class has its own configuration dialog presenting the specific
	options it provides. Furthermore, some classes depend on sub-classes
	(e.g. <classname>Boot Configs</classname> depend on "Qlustar Images"). Only the
	top-level config classes can be assigned to a host template. Sub-classes are assigned
	indirectly via their parent class. Most of the functional subsystems of
	<productname>Qlustar</productname> have a dedicated config class. Currently there are
	four of them: <classname>Boot Configs</classname>, <classname>DHCP Configs</classname>,
	<classname>Disk Configs</classname> and <classname>Slurm Configs</classname> with
	sub-classes <classname>Qlustar Images</classname> and <classname>UnionFS
	Groups</classname>.
      </para>
      <bridgehead>
	Writing Config Files
      </bridgehead>
      <para>
	The configurations managed via config classes and sub-classes in the
	<application>QluMan</application> GUI are translated into automatically generated
	configuration files on the head-node(s). While <application>QluMan</application>
	<!--cbox(preview_diff__diff_one.png)-->
	<!--cbox(preview_diff__diff_many.png)-->
	<!--cbox(preview_diff__view.png)-->
	configuration options are usually saved in the <application>QluMan</application>
	database immediately after they have been entered in the GUI, the write process of the
	real configuration files on disk is a separate step that needs to be specifically
	initiated and confirmed.
      </para>
      <para>
	Each configuration dialog of a config class has a <guibutton>Preview</guibutton> and
	<guibutton>Write</guibutton> button for its own config files. Additionally, there is
	also a dedicated dialog for writing and previewing <emphasis role="bold">all</emphasis>
	configuration files. You can access it from <guimenuitem>Manage
	Cluster</guimenuitem>-><guimenuitem>Write Files</guimenuitem> or the <guibutton>Write
	Files</guibutton> button at the bottom of the main window. If a config class has no
	pending changes, the <guibutton>Preview</guibutton> button becomes a
	<guibutton>View</guibutton> button and the <guibutton>Write</guibutton> button becomes
	ghosted. The Preview window shows both, the new version of the config file that will be
	written, as well as a <parameter>context diff</parameter> of the changes compared to
	the current file on disk (if there are any differences). If a config class changes only
	one file, the file will be shown directly. If multiple files are involved, there will
	be one tab for each file.
      </para>
      <para>
	Checking the optional <guibutton>Force</guibutton> button will initiate a rewrite of
	all config files, even if they haven't changed. Note also, that the actual write
	command is performed via the <xref linkend="Comand-execution"/>. This allows for
	<emphasis role="bold">consistent management of multiple head-nodes</emphasis> e.g. in a
	high-availability configuration.
      </para>
      <bridgehead>
	Boot Configs
      </bridgehead>
      <para>
	The "Boot Config" dialog allows to define settings for the PXE/tftp boot server.  A
	boot configuration determines which <xref linkend="Qlustar-OS-Images"
	endterm="Qlustar-OS-Images"/> is delivered to a node and optionally permits the
	specification of <firstterm>PXELinux</firstterm> commands and/or Linux kernel
	parameters. When opened, the <classname>Boot Config</classname> window shows a list of
	all boot configs currently
	<!--cbox(boot_config__collapsed.png)-->
	defined sorted by their names. Note that the default config is special in the sense
	that it applies to any node that has no specific boot config assigned (either through a
	template or directly) to itself. This means that in the simplest configuration (all
	nodes should boot identically), it is sufficient to just have the "default" boot config
	without any specific assignment. By expanding a boot config item, the configured
	<productname>Qlustar</productname> image, PXELinux command
	<!--cbox(boot_config__context_menu.png)-->
	and kernel parameters become visible. You can change any of the values by simply
	selecting a different option from the drop-down menus. In case of kernel parameters,
	you can also directly edit the entry and save the result by pressing
	<keycap>return</keycap>. Furthermore, it is possible to add more kernel parameters or
	remove them through the context menu.
      </para>
      <para>
	<!--cbox(boot_config__new.png)-->
	The context menu also lets you create new boot configs as well as edit or delete an
	existing one. Alternatively a new boot config can be created by clicking the
	<guibutton>New</guibutton> button at the bottom of the dialog. Both the context menu
	and the button bring up the <classname>New Boot Config</classname> dialog.  Simply
	enter the name for the new config, select a Qlustar image and (optionally) a PXELinux
	command, enter a description and press <guibutton>OK</guibutton> to create it. The new
	config then appears in the <classname>Boot Config</classname> window and is ready for
	use.  
	<note>
	  <para>
	    Note that additional kernel parameters can not be added in the <classname>New Boot
	    Config</classname> dialog or when editing an entry. This is only allowed via the
	    context menu, once the mouse is over the boot config to be changed.
	  </para>
	</note>
      </para>
      <bridgehead>
	DHCP Config
      </bridgehead>
      <para>
	<!--cbox(dhcp_config__global.png)-->
	The <classname>DHCP config</classname> dialog allows the configuration of the DHCP
	server and is provide by the main menu <guimenuitem>Manage
	Configs</guimenuitem>-><guimenuitem>DHCP Configs</guimenuitem>. The final DHCP server
	configuration file on disk is assembled from the header which defines global settings
	and the host part which contains the MAC/IP address and hostname of all the hosts
	registered with <application>QluMan</application>. The header can freely be edited in
	the <classname>Global DHCP Template</classname> part of the dialog. An initial version
	of it is created during installation and in most cases doesn't need to be changed. It
	contains many important parameters required for the cluster to function
	properly. Please consult the documentation of the DHCP server and the
	<filename>dhcpd.conf</filename> man page for the syntax of this file.
      </para>
      <para>
	<!--cbox(dhcp_config__edit_global.png)-->
	To prevent multiple persons from editing at the same time and overwriting each others
	changes accidentally you must acquire a lock for the template by clicking the
	<guibutton>Edit</guibutton> button. If another user is already editing the file the
	button will be ghosted and the tool tip will show which user is holding a lock for the
	template.
      </para>
      <para>
	<!--cbox(dhcp_config__save_global.png)-->
	After having finished editing a template don't forget to save your changes by clicking
	the <guibutton>Save</guibutton> button. It will be ghosted, if there is nothing to
	save. You can undo all your changes up to the last time the template was saved by
	clicking the <guibutton>Undo</guibutton> button. In case another admin has made changes
	to a template while you are viewing or editing it, the <guibutton>Refresh</guibutton>
	button will become enabled. By clicking it, the updated template is shown and you loose
	any unsaved changes you have already made in your own edit field. To delete a template
	click the <guibutton>Delete</guibutton> button.
	<note>
	  <para>
	    Note that the "Global Template" can not be deleted, since it is needed for the
	    DHCP server to function correctly.
	  </para>
	</note>
      </para>
      <para>
	<!--cbox(template__lock_expire.png)-->
	The template lock expires automatically after some time without activity so that the
	template is not deadlocked if someone forgets to release the lock. In such a case the
	above dialog will be shown notifying you about it. By selecting
	<guibutton>OK</guibutton> a new lock will be requested. If another user is editing the
	template at that time though the request will fail and an error dialog will inform you
	of the failure.
      </para>
      <para>
	<!--cbox(dhcp_config__menu.png)-->
	DHCP options can also be set in separate group templates and targeted to specific
	hosts. For simple clusters, this is hardly ever needed, but for large clusters e.g. you
	might want to have more than one boot server to speed up cluster boot time. In this
	case you could assign different groups of hosts to different boot servers using this
	method. The defined group templates are available as configs to be added to config sets
	or hosts directly. You can select a group template from the drop-down menu at the
	bottom to view or edit it. As an example 2 templates specifying different boot-servers
	are included.
      </para>
      <para>
	<!--cbox(dhcp_config__edit_new.png)-->
	<!--cbox(dhcp_config__new.png)-->
	The drop-down menu also lets you create new templates by selecting the <guimenuitem>new
	DHCP group</guimenuitem> entry. Enter the name of the template in the text field and
	fill in the contents and description of the template. Pressing <keycap>return</keycap>
	after entering the name will automatically acquire a lock for the new template and go
	into edit mode. You can then enter the contents of the new template. Don't forget to
	click the <guibutton>Save</guibutton> button at the end.
      </para>
      <para>
	When you are satisfied with your changes, you can preview the resulting
	<filename>dhcpd.conf</filename> file together with a diff to the old version on disk by
	clicking the <guibutton>Preview</guibutton> button. The changes will only take full
	effect when you click the <guibutton>Write</guibutton> button. This will also tell the
	DHCP server to reload its configuration. The same can also be done through the main
	menus <guimenuitem>Manage Cluster</guimenuitem>-><guimenuitem>Write Files</guimenuitem>
	entry or the <guibutton>Write Files</guibutton> button at the bottom of the cluster
	window and then selecting <guibutton>Preview</guibutton> or
	<guibutton>Write</guibutton> button in the DHCP Configs row.
      </para>
      <bridgehead>
	Disk Configs
      </bridgehead>
      <para>
	<productname>Qlustar</productname> has a powerful mechanism to manage the configuration
	of disks on a node. This mechanism is partly based on the setup_storage module of <link
	xlink:href="http://fai-project.org/___blank___">FAI</link>. It basically allows for any
	automatic setup of your hard drives including kernel software RAID (md) and
	<firstterm>LVM</firstterm> setups. A detailed description of the syntax for disk
	configurations is <link xlink:href="http://fai-project.org/doc/man/setup-storage.html">
	available</link>. Since the OS of a <productname>Qlustar</productname> node is always
	running from RAM, a disk-less configuration is obviously also possible. Note, that for
	flawless operation this requires some extra configuration (handling of log messages and
	in/output of batch jobs) that will be explained in the
	<productname>Qlustar</productname> admin guide. Valid configurations require
	definitions for two filesystems /var and /scratch as well as swap space (see
	examples). To permit the initial formatting of a new disk configuration on a node, it
	must have assigned the <parameter>Schedule Format: always</parameter> generic property
	during the initial boot (see the discussion <xref linkend="PropConf-Sets"
	endterm="PropConf-Sets"/>.
      </para>
      <para>
	<!--cbox(disk_configs.png)-->
	Disk configurations can be managed using the <classname>Disk Configs</classname> dialog
	accessible from the main menu <guimenuitem>Manage
	Configs</guimenuitem>-><guimenuitem>Disk Configs</guimenuitem>. You can select the
	config to be viewed/edited from the drop-down menu at the bottom left. A couple of
	example configurations are created during the installation. Note that there are two
	special configs: (a) "disk-less" (not editable or deletable) and (b) "default"
	(editable but not deletable). The default config is used for any node that doesn't have
	a specific assignment to a disk config (via a Host Template, config set). The
	configuration itself can be edited in the text field at the top of the dialog and
	should conform to setup_storage syntax (see above). New configs can be created by
	choosing <guimenuitem>new disk config</guimenuitem> from the drop-down menu. As usual,
	enter the name of the new config in the text field and fill in the contents and
	description.
      </para>
      <bridgehead>
	Slurm Config
      </bridgehead>
      <para>
	The slurm configuration module comes in three parts:
      </para>
      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      The overall slurm configuration being controlled through two templates in the
	      <classname>Config Header</classname> tab.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The configuration of slurm nodes done via the <classname>Node Groups</classname>
	      tab.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The configuration of partitions achieved using the
	      <classname>Partitions</classname> tab.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
      <para>
	 Assignment of hosts to node groups and/or partitions is possible by adding the latter
	 to the relevant <classname>Config Sets</classname> and <classname>Host
	 Templates</classname> or by direct assignment through the generic property context
	 menu.
      </para>
      <blockquote>
	<bridgehead>
	  Slurm Config Header
	</bridgehead>
	<para>
	  <!--cbox(slurm__preview.png)-->
	  <!--cbox(slurm_config__cgroups.png)-->
	  <!--cbox(slurm_config__editing.png)-->
	  <!--cbox(slurm_config__config.png)-->
	  The overall slurm configuration is split into two templates, the slurm config and
	  <filename>cgroups.conf</filename>. On write, <application>QluMan</application> adds
	  the NodeName and PartitionName lines at the end of the slurm config template to
	  generate the <filename>slurm.conf</filename> file, while the
	  <filename>cgroup.conf</filename> file gets written as is. For the syntax of both
	  templates, please refer to the slurm documentation (e.g. <code>man
	  slurm.conf</code>). To edit one of the templates, select it, click the
	  <guibutton>Edit</guibutton> button and start making changes. Click
	  <guibutton>Save</guibutton> to save the changes or <guibutton>Undo</guibutton> to
	  discard them. Use the <guibutton>Preview</guibutton> button to check changes before
	  writing them.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead>
	  Slurm Node Groups
	</bridgehead>
	<para>
	  <!--cbox(slurm__node_groups.png)-->
	  Slurm node properties are configured from two sources:
	</para>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
		The <xref linkend="Hardware-Properties" endterm="Hardware-Properties"/>
		assigned to a host. The number of CPUs, sockets, cores and the size of its main
		memory is taken from there.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		The second source are the slurm node groups. Every host can belong to at most
		one such group. The membership is defined (<xref linkend="SlurmAssignHost"
		endterm="SlurmAssignHost"/>) by adding the desired group to the <xref
		linkend="Config-Classes"/> that is assigned to the node via its <xref
		linkend="Host-Templates" endterm="Host-Templates"/>. Each Node Group is a
		collection of slurm node properties, that will be set for the members of the
		group. Per default, only the <code>MemSpecLimit</code> property is defined, but
		other properties like <parameter>Feature</parameter> or
		<parameter>Goes</parameter> can be added by using the <xref
		linkend="SlurmPropertyEditor" endterm="SlurmPropertyEditor"/>.
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  <!--cbox(slurm__node_groups__new3.png)-->
	  <!--cbox(slurm__node_groups__new2.png)-->
	  <!--cbox(slurm__node_groups__new1.png)-->
	  A new node group can be created by clicking the <guibutton>New Node Group</guibutton>
	  button or selecting <guimenuitem>New Node Group</guimenuitem> from the context
	  menu. This opens a dialog asking for the name of the new group.  An existing node
	  group can be renamed or deleted from the context menu.
	</para>
	<para>
	  <!--cbox(slurm__node_groups__change_property.png)-->
	  <!--cbox(slurm__node_groups__add_property1.png)-->
	  <!--cbox(slurm__node_groups__rename2.png)-->
	  <!--cbox(slurm__node_groups__rename1.png)-->
	  The context menu also allows to add properties to a group. Note, that some properties
	  are <emphasis role="bold">unique</emphasis>, i.e. only one value can be selected for
	  the property. Adding a second value of the same property will automatically replace
	  the old value in that case. Other properties are not unique. Adding multiple values
	  to such properties results in a comma separated list of values in the
	  <filename>slurm.conf</filename> file. An example for this is the
	  <parameter>Feature</parameter> property. Properties can also be changed directly
	  using the pull-down menu. If a change will cause a duplicate value, the previous
	  (duplicate) value is automatically removed.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="SlurmPartitions">
	  Slurm Partitions
	</bridgehead>
	<para>
	  <!--cbox(slurm__partitions.png)-->
	  The creation of Slurm partitions works exactly the same way as with slurm node
	  groups. Please see above for how to create, rename and change partitions.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="SlurmPropertyEditor">
	  Slurm Property Editor
	</bridgehead>
	<para>
	  The Slurm property editor for node or partition properties can be opened by clicking
	  the <guibutton>Properties</guibutton> button at the bottom of the Slurm main
	  dialog. If the <classname>Node Groups</classname> tab is selected, the editor for
	  node properties will be opened. If the <classname>Partitions</classname> tab is
	  selected, the editor for partition properties will be opened.
	</para>
	<para>
	  <!--cbox(slurm__node_groups__property_editor.png)-->
	  <!--cbox(slurm__node_groups__properties1.png)-->
	  To add a new property, enter the name of the property in the name field. If the name
	  does not already exist, the <guibutton>New Property</guibutton> button will be
	  enabled. Click on it to create the property. <application>QluMan</application> has a
	  white-list of known valid properties, e.g. <parameter>Gres</parameter> and allows
	  adding such a property without further questions. In this case,
	  <application>QluMan</application> will also set the unique flag and add all known
	  property values automatically.
	</para>
	<para>
	  <!--cbox(slurm__node_groups__property_editor__new_bad.png)-->
	  <!--cbox(slurm__node_groups__property_editor__new.png)-->
	  When a property is created that is not on the white-list (<emphasis
	  role="bold">Gris</emphasis> in the screenshot) a dialog opens up, asking for
	  confirmation. Note that adding an unknown property can lead to a failure when trying
	  to restart slurm. Therefore make sure to only add properties you are certain slurm
	  will know about. A property without values can be deleted by clicking the
	  <guibutton>Delete</guibutton> button.
	</para>
	<para>
	  <!--cbox(slurm__node_groups__property_editor__delete_value.png)-->
	  <!--cbox(slurm__node_groups__property_editor__add_value.png)-->
	  <!--cbox(slurm__node_groups__property_editor__delete.png)-->
	  <!--cbox(slurm__node_groups__property_editor__new_good.png)-->
	  To add values to a property, first select the desired property using the pull-down
	  menu from the name. Then enter the new property using <guibutton>Add
	  Value</guibutton> at the bottom and press <keycap>return</keycap> to add it. To
	  delete a value, select <guimenuitem>Delete value</guimenuitem> from the context menu.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="SlurmAssignHost">
	  Assigning Hosts to Slurm Node Groups and Partitions
	</bridgehead>
	<para>
	  <!--cbox(slurm__assign_host3.png)-->
	  <!--cbox(slurm__assign_host2.png)-->
	  <!--cbox(slurm__assign_host1.png)-->
	  Host are assigned to Slurm <classname>Node Groups</classname> and <emphasis
	  role="bold">Partitions</emphasis> by use of a <xref linkend="Host-Templates"
	  endterm="Host-Templates"/> and its corresponding <xref linkend="Config-Classes"/>. A
	  <classname>Config Set</classname> may contain at most one <classname>Node
	  Group</classname> but any number of <emphasis role="bold">Partitions</emphasis>,
	  since a host can be member of an arbitrary number of slurm
	  <!--cbox(slurm__assign_host5.png)-->
	  <!--cbox(slurm__assign_host4.png)-->
	  partitions. Both can be added by selecting them via <guimenuitem>Add
	  Config</guimenuitem> in the context menu of the <classname>Config Set</classname>.
	</para>
      </blockquote>
    </section>
    <section xml:id="Other-Configs">
      <title>Other Configs</title>
      <bridgehead xml:id="Qlustar-OS-Images">
	Qlustar OS Images
      </bridgehead>
      <para>
	<!--cbox(qlustar_images.png)-->
	Qlustar OS images can be defined and configured in the <classname>Qlustar
	Images</classname> dialog accessible via <guimenuitem>Manage
	Configs</guimenuitem>-><guimenuitem>Qlustar Images</guimenuitem>. Each image has a
	unique name, a flavor (currently only <classname>precise</classname>), a version, a
	<xref linkend="UnionFS-Chroots" endterm="UnionFS-Chroots"/> and one or more image
	modules.
      </para>
      <blockquote>
	<bridgehead>
	  Image Versioning
	</bridgehead>
	<para>
	  Currently available image versions are 9, 9.0 (both meta-versions) and 9.0.0. Note,
	  that selecting meta-versions has implications on the update process. They allow
	  tracking the newest x.y (x.y.z) releases automatically. Example: If you have
	  installed version 9 of the modules, you will currently get the 9.0 (most recent 9.y)
	  versions, but when 9.1 will be
	  <!--cbox(qlustar_images__modules.png)-->
	  available, <code>apt-get dist-upgrade</code> will update to 9.1 versions
	  automatically. So with this choice, updates will usually include larger changes,
	  since new <emphasis role="bold">feature</emphasis> releases (like 9.1) will
	  automatically be installed. Similar, if you have selected the 9.0 version (currently
	  default after a fresh installation) you will currently get 9.0.0 (most recent 9.0.z
	  version) and <code>apt-get dist-upgrade</code> will update the modules/images to
	  9.0.1 automatically once available. So this choice will update to new <emphasis
	  role="bold">maintenance</emphasis> releases automatically. The most conservative
	  choice would be to explicitly select a x.y.z version (currently 9.0.0), since then
	  images will only receive bug fix updates without explicitly changing the version in
	  <productname>Qlustar</productname>. See also the discussion in the general <link
	  xlink:href="https://qlustar.com/book/docs/qlustar-update-procedure/___blank___">
	  Qlustar Update Guide</link>
	</para>
      </blockquote>
      <blockquote>
	<bridgehead>
	  Image Properties
	</bridgehead>
	<para>
	  <!--cbox(qlustar_images__new.png)-->
	  A couple of images are pre-defined during the installation process. The dialog shows
	  the images sorted by their names. Expanding an entry shows its configuration and
	  allows to select a UnionFS chroot via the drop-down menu. Each image must contain at
	  least the core module. Additional modules can be added or removed using the context
	  menu when hovering over an entry. Only modules that are not already chosen are
	  available for selection.
	</para>
	<para>
	  New images can be added through the context menu or by pressing the
	  <guibutton>New</guibutton> button at the bottom of the dialog. Like before, you
	  should then enter the name for the new config, choose a UnionFS group and optionally
	  provide a description for the new image. Existing images can be removed via the
	  context menu.
	</para>
      </blockquote>
      <bridgehead>
	NIS hosts
      </bridgehead>
      <para>
	<!--cbox(nis_host_header.png)-->
	NIS (network information system) is used to manage hostname resolution within the
	cluster. For all hosts that are managed within <application>QluMan</application>
	itself, a corresponding NIS entry is created automatically. However, administrators
	might want to add other hosts external to the cluster to the NIS database as well. To
	achieve this, the creation of the NIS hosts database is split into a header part that
	can be freely edited by the admin, and a part that is auto-created with the hosts
	managed by <application>QluMan</application>. To edit the header part, choose
	<guimenuitem>Manage Configs</guimenuitem>-><guimenuitem>NIS Host Header</guimenuitem>
	from the main menu. The top part of the window popping up can then freely be
	edited. Note that entries for the head-node are automatically created upon installation
	and should remain unchanged unless one of the head-nodes IP changes. The resulting NIS
	hosts file can then be previewed and written to disk by pressing the corresponding
	dialogs at the bottom of the dialog. Upon writing the file, the NIS database is
	automatically rebuilt on the NIS master server.
      </para>
      <bridgehead>
	SSH host files
      </bridgehead>
      <para>
	<!--cbox(ssh_hosts__known.png)-->
	To simplify ssh remote logins to cluster nodes, three ssh configuration files are
	provided and managed by <application>QluMan</application>: (a)
	<filename>ssh_known_hosts</filename> (holds ssh host keys of cluster nodes), (b)
	<filename>shosts.equiv</filename> (enables login without password between machines
	within the cluster) and (c) <filename>authorized_keys</filename>, which is used to
	allow password-less root login to nodes with the specified ssh public keys. The first
	two config files consist of a configurable header part, where additional hosts can
	freely be entered and an auto-generated part for the hosts managed by
	<application>QluMan</application>. The last one just has the configurable part. Ssh
	host info for the head-node and a possibly configured frontend-node are automatically
	inserted during the installation process.
      </para>
      <para>
	<!--cbox(ssh_hosts__authorized_keys.png)-->
	<!--cbox(ssh_hosts__equiv.png)-->
	Management of the three configs is similar to the <classname>NIS hosts</classname>
	dialog: To edit the header part of either config, select <guimenuitem>Manage
	Configs</guimenuitem>-><guimenuitem>SSH Configs</guimenuitem> from the main menu. Then
	choose the config to work on by using the drop-down menu at the bottom left. The top
	part of the window popping up can then freely be edited. Finally, the resulting ssh
	host files can be previewed and written to disk by pressing the corresponding dialogs
	at the bottom of the dialog.
	<note>
	  <para>
	    There is no preview of the <filename>authorized_keys</filename> file, as this is
	    automatically written during the boot phase on hosts, that are not head-nodes.
	  </para>
	</note>
      </para>
      <bridgehead xml:id="UnionFS-Chroots">
	UnionFS Chroots
      </bridgehead>
      <para>
	In most practical cases, a <productname>Qlustar</productname> image should be
	configured with an associated UnionFS chroot. Exceptions are single purpose images
	e.g. for Lustre servers. By design, images are stripped down to the functionality
	(programs) that is most often needed on a compute/storage node. This keeps them small
	while still providing fast, network-independent access to programs/files typically
	used.
      </para>
      <para>
	To complement the image and provide the full richness of the packages/programs
	available in the chosen Linux distribution, the UnionFS chroot (holding a full
	installation of e.g. Ubuntu) is exported via NFS by one of the head-nodes and
	technically <emphasis role="bold">merged below</emphasis> the content of the
	<classname>Qlustar OS image</classname>. In practice, this means that all files
	belonging to the chroot will be available on the nodes configured to use it, but if a
	file/program is also in the node's image, that one will be used. Hence, this method
	combines the <emphasis role="bold">compactness and speed</emphasis> of the imaging
	approach with the <emphasis role="bold">completeness</emphasis> of a full OS
	installation to give you the best of all worlds.
      </para>
      <para>
	<!--cbox(manage_chroots.png)-->
	<!--cbox(menu-manage_cluster__manage_chroots.png)-->
	The chroot associated with a Qlustar image is easily selectable as explained <xref
	linkend="Qlustar-OS-Images" endterm="Qlustar-OS-Images"/>. Management of the chroots
	themselves is possible via the <classname>Manage Chroots</classname> dialog which is
	accessible via the main menu <guimenuitem>Manage
	Cluster</guimenuitem>-><guimenuitem>Manage Chroots</guimenuitem>. It provides a number
	of actions related to chroots. Manipulation of the contents of chroots is explained
	<link xlink:href=
	"https://qlustar.com/book/docs/first-steps#Adding-Software">elsewhere</link>.
      </para>
      <para>
	<!--cbox(manage_chroots__select_chroot.png)-->
	To <emphasis role="bold">specify a chroot to operate on</emphasis>, select it via the
	corresponding pull-down menu. This will show its description, as well as its properties
	like the NFS server that hosts it, the filesystem path on the server, the flavor (edge
	platform, precise/wheezy/...)  and the version of the
	<productname>Qlustar</productname> feature release (always being of the form x.y, e.g
	8.1).
      </para>
      <para>
	<!--cbox(manage_chroots__new2.png)-->
	<!--cbox(manage_chroots__new1.png)-->
	When <emphasis role="bold">generating a new chroot</emphasis>, a name for the chroot
	must be specified and optionally a description of its purpose. Furthermore, you can
	select an NFS server where the chroot will be located (currently only one option), a
	flavor (aka edge platform) and <productname>Qlustar</productname> version. Finally you
	have the possibility to select <classname>Qlustar tasks</classname>. These are topic
	package bundles, each consisting of a collection of packages relevant to a certain
	field of HPC applications. Pressing the <guibutton>OK</guibutton> button then starts
	the generation of the chroot. You can follow the rather lengthy process (count a couple
	of minutes) in its own window.
      </para>
      <para>
	<!--cbox(manage_chroots__edit.png)-->
	<!--cbox(manage_chroots__clone2.png)-->
	<!--cbox(manage_chroots__clone1.png)-->
	<emphasis role="bold">Cloning an existing chroot</emphasis> is mostly useful when you
	want to test an upgrade to a new release or for other tests. Pressing the
	<guibutton>Clone</guibutton> button opens a sub-window in which you can specify the
	name of the new cloned chroot and optionally a description of its purpose. Pressing the
	<guibutton>OK</guibutton> button then starts the cloning process. You can again watch
	it in its own window. Editing a chroot let's you edit it's description.
      </para>
      <para>
	<!--cbox(manage_chroots__remove3.png)-->
	<!--cbox(manage_chroots__remove2.png)-->
	<!--cbox(manage_chroots__remove1.png)-->
	<emphasis role="bold">Removal of a chroot</emphasis> by pressing the
	<guibutton>Remove</guibutton> button first asks you for a final confirmation. If you
	then press the <guibutton>Delete</guibutton> button, the chroot will be removed
	provided it is not still in use by a Qlustar image. If it is still in use, a list of
	images that are associated with the chroot is given. You would then first have to
	reconfigure these images to use another chroot before trying to remove again. <emphasis
	role="bold">Renaming of a chroot</emphasis> is not supported directly. To rename you'd
	have to clone the original chroot giving the clone the new desired name and afterwards
	remove the old chroot.
      </para>
      <bridgehead xml:id="Configuring-IB">
	Infiniband network
      </bridgehead>
      <para>
	For most practical purposes, Infiniband (IB) adapters need to be configured with an IP
	address (IPoIB) just like Ethernet adapters. If you have chosen to configure an IB
	network during installation, this section is mostly about how to review or change the
	initial
	<!--cbox(network_config__infiniband.png)-->
	settings. If not, IB first has to be activated in the <xref
	linkend="Configuring-the-Network"/> dialog. An IB Network address IP and netmask can
	then be chosen. The Infiniband network must not collide with the Cluster (Ethernet) or
	IPMI network. This is prevented automatically in the settings dialog. The Infiniband IP
	of each host is computed by mapping the host part of its Cluster Network IP to the IB
	Network. Example: IP Cluster Network 192.168.52.100 - IP IB network
	192.168.53.100. Note, that this mechanism requires the IB netmask to be at least as
	large as the Cluster Network netmask. Hence, smaller values won't be selectable.
      </para>
      <para>
	<!--cbox(hardware_property_set__ib.png)-->
	To actually have a node's IB adapter be configured during the boot process, additional
	steps are necessary. It is not uncommon, that a cluster consists of hosts with IB and
	hosts without. Therefore, the pre-defined hardware property <parameter>IB
	Adapter</parameter> with a value of <parameter>true</parameter> must be assigned to a
	host, to explicitly enable IB for it. This is done most conveniently, by adding this
	property to the Hardware Property Set(s) used in the Host Template(s) for nodes with
	IB. If this assignment exists, Infiniband modules will be loaded and IP-over-IB will be
	configured during the boot process of the corresponding nodes with the IP mapping
	described above.
      </para>
      <blockquote>
	<bridgehead>
	  Activating/configuring OpenSM
	</bridgehead>
	<para>
	  In an IB fabric, at least one node (or switch) has to run a subnet manager to manage
	  the routing tables. Qlustar provides <application>OpenSM</application> for this
	  task. If the head-node is also part of the IB network, it's usually best to configure
	  it to run OpenSM. This might have
	  <!--cbox(opensm__port_all.png)-->
	  been chosen during installation, in which case there is nothing more to be done. If
	  not, you have the option to run OpenSM on ordinary nodes too. In this case, it is
	  advisable to run OpenSM on two or three nodes (not more) for redundancy reasons. It
	  is therefore best, to configure this directly for the chosen hosts, rather than using
	  a Host Template or generic property set.  After selecting the host or hosts where
	  OpenSM should run in the Enclosure View, open the context menu and select
	  <guimenuitem>Set Generic Property</guimenuitem>-><guimenuitem>OpenSM
	  Ports</guimenuitem>-><guimenuitem>ALL</guimenuitem>. The next time the hosts boots,
	  the OpenSM daemon will be started on all its Infiniband ports.
	</para>
	<para>
	  <!--cbox(opensm__port_create_1.png)-->
	  <!--cbox(opensm__port_1.png)-->
	  If a host has more than one IB port, OpenSM can also be configured to run only on a
	  specific port instead of all of them. The port can be specified by its number or by
	  its unique ID. As this is an uncommon configuration and the unique ID is unknown
	  beforehand, there is no preset value for this. To create a new value, first select an
	  existing value, e.g. ALL, for the generic property <literal>OpenSM
	  Ports</literal>. You can then edit the value in the <classname>Generic
	  Properties</classname> box of a host. Editing the line and pressing
	  <keycap>return</keycap> will create the new value. Beware that this will only affect
	  one shown host. To assign the new value to other hosts, select them and then change
	  the OpenSM Ports property through the context menu.
	</para>
	<para>
	  <!--cbox(opensm__option_edit.png)-->
	  <!--cbox(opensm__option_add.png)-->
	  In some circumstances it might be necessary to run OpenSM with extra options. This
	  can also be configured via generic properties. The only preset value is the empty
	  string, so you need to create a new value for the options you require. First add the
	  empty value of the generic property <classname>OpenSM Options</classname> to one
	  host. Edit the value to your requirements and press <keycap>return</keycap> to create
	  it. Finally add/change the OpenSM Options generic property to all relevant hosts.
	</para>
      </blockquote>
      <bridgehead>
	IPMI settings
      </bridgehead>
      <para>
	<!--cbox(network_config__ipmi.png)-->
	Configuring IPMI is similar to Infiniband and also involves multiple steps, because
	there are a number of options to set. If you have chosen to configure an IPMI network
	during installation, a larger part of this section is about how to review or change the
	initial settings. If not, IPMI first has to be activated in the <xref
	linkend="Configuring-the-Network"/> dialog. There you can set the IPMI Network address
	IP and netmask. The IPMI address of a host is then determined with the same mapping as
	<xref linkend="Configuring-IB" endterm="Configuring-IB"/> and the same restrictions for
	the choice of netmask apply.
      </para>
      <para>
	<!--cbox(hardware_property_set__ipmi.png)-->
	Often not all nodes in a cluster have IPMI. Therefore, in
	<application>QluMan</application> per default no host is configured to setup IPMI,
	unless it is assigned the hardware property <literal>IPMI Adapter</literal> with a
	value of <parameter>true</parameter>. The easiest way to achieve this, is to add the
	<literal>IPMI Adapter</literal> property to the Hardware Property Set(s) used in the
	Host Template(s) for the nodes with IPMI. With this assignment, a node is ready for
	monitoring its temperature and fan speeds.
      </para>
      <para>
	<!--cbox(generic_property_set__ipmi_channel_add.png)-->
	<!--cbox(generic_property_set__ipmi_initialize_add.png)-->
	Enabling IPMI nodes for remote control involves two more settings. The first one is the
	generic property <parameter>Initialize IPMI</parameter>. Per default the settings of
	the IPMI cards are not touched by <productname>Qlustar</productname>. However, while
	the <parameter>Initialize IPMI</parameter> generic property is assigned and set to
	<parameter>true</parameter>, the IPMI card settings of the corresponding host will be
	reset every time it boots. Changing the value of this property to
	<parameter>true</parameter> and after booting back to <parameter>false</parameter>
	allows a one-time setup of the cards properties.
      </para>
      <para>
	<!--cbox(generic_property_set__ipmi_channel_edit.png)-->
	The second generic property is the <parameter>IPMI Channel</parameter> to use. Per
	default channel 1 is used and this is the only preset value for the property. If you
	need to use a different channel, first add the generic property <parameter>IPMI
	Channel</parameter> to the <classname>Generic Property Set</classname> (or to a host
	directly) and then edit the value.
      </para>
    </section>
    <section xml:id="Comand-execution">
      <title>RXEngine / Remote Execution Engine</title>
      <para>
	<!--cbox(execute__overview.png)-->
	<application>QluMan</application> provides a powerful <classname>remote command
	execution engine</classname>, that allows to run shell commands on any number of hosts
	in <emphasis role="bold">parallel</emphasis> and analyze their output/status in
	<emphasis role="bold">real-time</emphasis>. Commands fall into two categories:
	<literal>Pre-defined commands</literal> and <literal>custom commands</literal>.
      </para>
      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      The command can be a single command or a series of commands in shell syntax.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The hosts are specified in <literal>Hostlist format</literal> or through a
	      <literal>filter</literal>, so that even large groups can be represented by a
	      short string.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The commands run in parallel on all hosts.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The network connection used for remote execution is both <emphasis
	      role="bold">encrypted and authenticated</emphasis>. It employs the same
	      high-speed/high-security elliptic-curve cryptography that is used for the
	      connection between the <application>QluMan server</application> and the
	      <application>QluMan GUI</application>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The output is <emphasis role="bold">analyzed</emphasis> and updated in short
	      intervals during the execution phase.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Hosts with equal output are <emphasis role="bold">grouped</emphasis> together to
	      reduce the noise.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The output can further be <emphasis role="bold">filtered</emphasis> by the return
	      code of the command and by (de)selecting <literal>stdout</literal> and/or
	      <literal>stderr</literal>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
      <bridgehead>
	Executing a pre-defined command
      </bridgehead>
      <para>
	<!--cbox(execute_predefined2.png)-->
	<!--cbox(execute_predefined1.png)-->
	<!--cbox(enclosure_view__execute_predefined.png)-->
	Pre-Defined commands can be created using the <classname>Command Editor</classname>
	(see <xref linkend="CommandEditor"/> for details). To execute a pre-defined command,
	open the pull-down menu of the <guibutton>Execute button</guibutton> at the bottom of
	the <classname>Enclosure View</classname> and select an entry. This opens a new
	<classname>Command Execution</classname> window for pre-defined commands. At the very
	top of it, the selected pre-defined command is shown. It can be changed if
	required. Below that is a list of arguments, the selected command
	accepts. <guilabel>Execute on</guilabel> is always present showing where the command
	will be executed. If defined, additional arguments of the command are displayed
	underneath. Further below, the final command is shown, with its arguments inserted at
	the right places. The command will be executed upon clicking the
	<guibutton>Execute</guibutton> button.
      </para>
      <para>
	<!--cbox(execute_predefined4.png)-->
	<!--cbox(execute_predefined3.png)-->
	<!--cbox(enclosure_view__execute_predefined2.png)-->
	Arguments to a pre-defined command can be set fixed to a <xref
	linkend="HostFilterEditor"/> , in which case the filter and its resulting hostlist are
	shown as plain text and can not be edited. Optionally, specification of arguments in
	Hostlist format may also be left up to the user. In that case, a combo-box is shown,
	followed by the evaluation of the specified input shown as plain text. When hosts were
	selected in the <classname>Enclosure View</classname>, the combo-box will contain the
	hostlist corresponding to the selection as default. The text can be edited directly or
	a filter can be chosen from the dropdown menu. Any argument starting with "%" is
	assumed to be a filter. If this is not intended, the "%" must be escaped by another
	"%", but only at the start of an argument. For more details about specifying arguments
	in pre-defined commands see <xref linkend="CommandEditor"/>.
      </para>
      <bridgehead>
	Executing a custom command
      </bridgehead>
      <para>
	<!--cbox(execute.png)-->
	<!--cbox(enclosure_view__execute.png)-->
	To execute a custom command, open the pull-down menu of the <guimenu>Execute
	button</guimenu> at the bottom of the <classname>Enclosure View</classname> and select
	custom command from the menu. This opens a new blank <classname>Command
	Execution</classname> window.
	<note>
	  <para>
	    The initial hostlist is empty in the screenshot examples, since no hosts where
	    selected in the <classname>Enclosure View</classname>
	  </para>
	</note>.
      </para>
      <para>
	<!--cbox(execute__past_command.png)-->
	<!--cbox(execute__update.png)-->
	<!--cbox(execute__selected.png)-->
	In case hosts were selected in the <classname>Enclosure View</classname> before
	clicking the <guibutton>Execute</guibutton> button, a hostlist representing these hosts
	will be present in the <classname>Command Execution</classname> window. This allows
	<emphasis role="bold">easy selection of hosts</emphasis> to run a command on via the
	<classname>Enclosure View</classname> or through the <xref linkend="Selection"
	endterm="Selection"/>. The hostlist can also be updated at a later time from the
	currently selected hosts in the Enclosure View by clicking the
	<guibutton>Update</guibutton> button. This makes it simple, to run the same command on
	different sets of hosts. When a command is executed, it is added to the
	<literal>history</literal> and can be accessed again later through the pull-down
	menu. This allows rerunning recently used commands without having to retype them every
	time.
	<note>
	  <para>
	    Note, that the history is stored in the users home directory, hence every user has
	    his own. The preferred way to manage frequently used commands is by pre-defining
	    them (explained <xref linkend="CommandEditor"/>).
	  </para>
	</note>
      </para>
      <bridgehead>
	Running Commands / Interpreting their Output
      </bridgehead>
      <para>
	<!--cbox(execute__command.png)-->
	Once the hostlist is added, a command can simply be run by entering it in the command
	box and hitting the <guibutton>Execute</guibutton> button. It will then start to run in
	parallel on all listed hosts and the command output will be collected. Periodically, in
	short but increasing intervals, the <emphasis role="bold">output will be
	sorted</emphasis>> and displayed. Hence, for short running programs you will see it
	immediately. Due to the increasing display intervals, long running and noisy commands
	won't cause constant flickering of the output, allowing you to more easily follow it.
      </para>
      <bridgehead>
	Command State
      </bridgehead>
      <para>
	<!--cbox(execute__df.png)-->
	After the <guibutton>Execute</guibutton> button has been pressed, all hosts will start
	in the <literal>Pending state</literal>. Once a host confirms that it has started its
	command, it will change to the <literal>Running state</literal>. When the command
	concludes, the state becomes one of <literal>Failed</literal>,
	<literal>Errors</literal> or <literal>Success</literal>. If the command exited with a
	return code other than 0, the host will enter the <literal>Failed</literal> state. If
	the command exited with a return code of 0, but produced output on
	<literal>stderr</literal>, it will enter the <literal>Errors</literal>
	state. Otherwise, it enters the <literal>Success</literal> state.
      </para>
      <para>
	<!--cbox(execute__killed.png)-->
	<!--cbox(execute__pending.png)-->
	In the screenshot example, the hosts <systemitem class="systemname">sn-1</systemitem>
	and <systemitem class="systemname">sn-2</systemitem> were down, so they remained in the
	<literal>Pending</literal> state. By clicking the <guibutton>Pending</guibutton>
	button, a hostlist of the pending hosts is displayed. The <application>QluMan
	server</application> will start the command on those hosts, when they become online
	again. If you do not want that to happen, or if the command does not terminate on its
	own, then the <guibutton>Kill</guibutton> button allows you to stop the command.  A
	killed command counts as failed, so <systemitem class="systemname">sn-1</systemitem>
	and <systemitem class="systemname">sn-2</systemitem> now enter that state. The command
	output also reflects that the command was killed.
      </para>
      <bridgehead>
	Hosts and Groups
      </bridgehead>
      <para>
	<!--cbox(execute_group.png)-->
	Hosts executing a command are not only grouped by their execution state, the command
	output produced by the different hosts is also <emphasis role="bold">analyzed and
	compared</emphasis> to each other. Hosts with identical output are put into a
	group. Their output is only displayed once, prefixed with the hostlist representing the
	hosts in each group. For a quick overview, the number of hosts and groups is also
	displayed below each state button. In the screenshot example, two hosts (<systemitem
	class="systemname">sn-1</systemitem> and <systemitem
	class="systemname">sn-2</systemitem>) have failed, because they where offline and the
	command was killed before starting. The output of both was identical, so they form one
	group. Similar, one host (<systemitem class="systemname">ql-head-pr-t</systemitem>)
	completed the command successfully and builds its own group.
      </para>
      <para>
	The <guibutton>S</guibutton> buttons next to the numbers add or remove the hosts in
	each state to form a new hostlist. Press the button to include the corresponding hosts
	and press it once more to exclude them again. This is convenient, e.g. to quickly
	select only the hosts for which a command failed: Analyze the errors and later relaunch
	with an adjusted command. Another example: Select only the successful hosts to run a
	follow-up command etc.
      </para>
      <bridgehead>
	Filtering by stdout and stderr
      </bridgehead>
      <para>
	<!--cbox(execute__errors.png)-->
	Commands usually output regular text to <literal>stdout</literal> and warnings as well
	as errors to <literal>stderr</literal>. In the latter case, the command ends up in the
	<literal>Errors</literal> state, because this is usually something that needs further
	inspection. The screenshot example prints two lines, one to <literal>stderr</literal>
	and one to <literal>stdout</literal>. Unfortunately Unix does not enforce any order
	between output to <literal>stdout</literal> and <literal>stderr</literal>. Therefore,
	as in this example, it can happen, that a small delay between the command output and
	reading from the file descriptors causes the order to slightly change.
      </para>
      <para>
	<!--cbox(execute_stderr.png)-->
	<!--cbox(execute__stdout.png)-->
	Some commands produce a lot of output. Error messages are then easily overseen in
	between the lines. Similarly a command might report a lot of harmless errors, that hide
	the interesting output going to <literal>stdout</literal>. To simplify an analysis of
	the command output for such cases, the two buttons <guibutton>stdout</guibutton> and
	<guibutton>stderr</guibutton> at the bottom of the window allow <emphasis
	role="bold">toggling the visibility</emphasis> of <literal>stdout</literal> and
	<literal>stderr</literal> output selectively on and off.
      </para>
      <bridgehead>
	Passing input to a command
      </bridgehead>
      <para>
	<!--cbox(execute__input.png)-->
	Sometimes it is necessary to pass some input to a command. This can be done by clicking
	the <guibutton>Input</guibutton> button near the top. Another text box will then be
	added to the window and will allow to specify, what should be passed to
	<literal>stdin</literal> of the command on each host. <!--FIXME: rewrite when
	implemented In future version the Browse button will allow selecting a file to be used
	as stdin. -->
      </para>
      <bridgehead>
	Command Syntax
      </bridgehead>
      <para>
	Commands will be interpreted/executed by the <literal>BASH</literal> shell on every
	host matching the hostlist. The full <literal>BASH</literal> syntax is
	supported. Redirection of output to files, as in the last example, and working with
	variables works as expected. Please refer to the <literal>BASH</literal> documentation
	(e.g. <code>man bash</code>) for more details.
      </para>
    </section>
    <section xml:id="CommandEditor">
      <title>Command Editor</title>
      <para>
	<!--cbox(command_editor__ls.png)-->
	<!--cbox(command_editor.png)-->
	The <classname>command editor</classname> shows all the pre-defined commands in a tree
	view on the left. A number of useful commands are already defined by default. Selecting
	a command shows its definition on the right-hand side, where it can also be
	edited. Every command has a unique name/alias under which it appears in the tree view
	on the left, the execute menu in the <classname>Enclosure View</classname> and in the
	drop down menu of the pre-defined commands execution window. In the future, it will
	also be possible to limit commands to specific user roles, but for now all commands are
	unrestricted. A user either has rights to execute any pre-defined commands or
	none. Below the role selector, the command itself is defined.
      </para>
      <bridgehead xml:id="CommandEditor-defining">
	Defining or editing a command
      </bridgehead>
      <para>
	<!--cbox(command_editor__new2.png)-->
	<!--cbox(command_editor__new1.png)-->
	<!--cbox(command_editor__rename.png)-->
	To define a new command, select <guimenuitem>New Command</guimenuitem> from the context
	menu. The new command will be created in the group, where the context menu was opened
	or in the root, if the mouse is outside of any group. Initially, the command will have
	no definitions.
      </para>
      <para>
	To edit a command, it needs to be selected first. Then its definitions will be shown on
	the right-hand side. The name/alias of a command can be edited by clicking in the text
	box at the top and entering the new name. The check-box to the right of the name
	indicates, whether your name is valid. Press enter, to save the new name and the
	check-box will become fully checked again. To undo editing, simply reselect the command
	in the tree view.
      </para>
      <para>
	<!--cbox(command_editor__execute_on2.png)-->
	<!--cbox(command_editor__execute_on.png)-->
	A command can be executed on any host or set of hosts in the cluster. The
	<guilabel>Execute on</guilabel> field governs how that host or set of hosts is
	constructed. The default is <parameter>User input</parameter>. This means, the user
	will have to choose the hostlist, where the command will run, at the time, when it will
	be executed. Alternatively, the hostlist of the command can be preset by selecting one
	of the filters from the dropdown menu. If a filter is selected, the hostlist, it
	currently evaluates to, is displayed below it.
      </para>
      <para>
	<!--cbox(command_editor__edit2.png)-->
	<!--cbox(command_editor__edit.png)-->
	Editing the command itself may take a while. To avoid conflicts from concurrent editing
	attempts by different <application>QluMan</application> users, only one person can edit
	a command at a time. To start the editing process, click the
	<guibutton>Edit</guibutton> button at the bottom. After that, changes to the command
	can be entered. Commands will be interpreted/executed by the <literal>BASH</literal>
	shell on every host matching the hostlist. The full BASH syntax is
	supported. Redirection of output to files and working with variables works as
	expected. Please refer to the BASH documentation (e.g. <code>man bash</code>) for more
	details. There is one exception to this: A "%" character followed by a number specifies
	additional arguments for the command, as explained in more detail below.
      </para>
      <para>
	<!--cbox(command_editor__edit5.png)-->
	<!--cbox(command_editor__edit4.png)-->
	<!--cbox(command_editor__edit3.png)-->
	Sometimes it is necessary, to pass some input to a pre-defined command. This can be
	done by clicking the <guibutton>Input</guibutton> check-box. It will bring up an input
	text-box, where the desired input text can be entered.
      </para>
      <para>
	To finish editing the command, click the <guibutton>Save</guibutton> button at the
	bottom. This actually saves the command text and input, if any, in the database and
	releases the lock on the command. This also scans the command text for argument
	placeholders and updates the entries in the <classname>Arguments</classname> box.
      </para>
      <para>
	<!--cbox(command_editor__arguments.png)-->
	The definition of command arguments use the same mechanism as detailed for the
	<literal>Execute on</literal> definition. They can either be left up to the user to
	fill in, when the command is executed or be specified by a filter selectable from the
	dropdown menu. When executed, the <replaceable>num</replaceable> placeholders in the
	command text are replaced by the user specified arguments or the resulting hostlist of
	the filter. There are always as many arguments as there are placeholders in the
	command. To add an argument, edit the command text and add a placeholder there. To
	remove an argument, edit the command text and remove the placeholder.
      </para>
      <para>
	<!--cbox(command_editor__testing_command.png)-->
	In the screenshot example, the test command is defined to execute on all head-nodes
	(<systemitem class="systemname">qlu-dev</systemitem> is the only head node in the
	cluster). It has some input and two extra arguments. The first one is fixed to a
	Hostname filter, that evaluates to any host starting with <systemitem
	class="systemname">beo</systemitem>. The second one is left for the user to be
	specified, hence, when executing the command, only the second argument is editable. In
	the screenshot, the <literal>ONLINE</literal> filter was chosen for this argument, but
	any other text would have been possible too. For easy verification, the command text,
	with all the arguments substituted, is shown together with the command input (if
	defined). Note that in the example, the specified input is simply output by the
	<command>cat</command> command, so in the output shown, it appears between the two
	<command>echo</command> commands.
      </para>
    </section>
    <section xml:id="HostFilterEditor">
      <title>Host Filter Editor</title>
      <para>
	<!--cbox(filter_editor.png)-->
	Host filters define a set of hosts by specifying any number of criteria. The set of
	hosts defined by a filter is dynamic: Changes made to the properties of hosts are
	automatically reflected in the hostlist a filter evaluates to. Every time a filter is
	used, the criteria defining it are evaluated from scratch. Hence, host filters provide
	a powerful tool to classify hosts into groups, in a way that will dynamically take into
	account changes made to the cluster. They can be used in various ways within
	<application>QluMan</application>:
      </para>
      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      In pre-defined commands, to either specify, the set of hosts, where a command
	      should be executed or to supply the resulting hostlist as an argument to the
	      command.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      As user input for pre-defined or custom commands.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      In the <classname>Enclosure View</classname> to modify the selection.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
      <para>
	<!--cbox(filter_editor__select_filter.png)-->
	The filter editor window is split into two areas. At the top the definition of the
	currently selected filter is shown. You can select the filter to be displayed from the
	dropdown menu. At the bottom the hosts that pass all the filters are displayed in the
	compact HostList format. This format is used by a number of other programs including
	pdsh and SLURM (the <link
	xlink:href="https://code.google.com/p/pdsh/wiki/HostListExpressions/___blank___">pdsh
	Wiki</link> has a detailed discussion on the syntax).
      </para>
      <para>
	<!--cbox(filter_editor__new3.png)-->
	<!--cbox(filter_editor__new2.png)-->
	<!--cbox(filter_editor__new.png)-->
	<!--cbox(filter_editor__new5.png)-->
	<!--cbox(filter_editor__new4.png)-->
      </para>
      <para>
	Select <guimenuitem>new filter</guimenuitem> from the dropdown menu to start defining a
	new filter. Then add filters from the context menu, until the desired subset of hosts
	is displayed in the bottom half of the window. Using their context menu, filters can be
	edited or removed and sub-filters be added. The <guimenuitem>Reset filter</guimenuitem>
	menu item clears the filter, so one can start from scratch. To finally create (save)
	the new filter click <guibutton>Save as</guibutton> and enter a name for it.
      </para>
      <bridgehead xml:id="HostFilterEditorEdit">
	Editing a Filter
      </bridgehead>
      <para>
	Editing a filter is similar to creating a new one. First select the filter from the
	dropdown menu to display it's current definition. Then add, edit or remove individual
	filters as desired. Finally click <guibutton>Save as</guibutton> to save the altered
	filter, Using an existing name will replace the old filter. Using a different name will
	create a new filter.
      </para>
      <bridgehead xml:id="HostFilterEditorFilterTypes">
	Types of Filters
      </bridgehead>
      <para>
	<!--cbox(filter_editor__new3.png)-->
	A filter can be added from the context menu (right mouse click) in the top area.  For a
	host to show up in the filtered list (bottom part), it must pass all the filters added.
	Each filter narrows down the list. Any number of filters can be added and they do not
	have to be unique. For example you can add a Hostname filter that selects all hosts
	that begin with <systemitem class="systemname">beo</systemitem> and a Host Template
	filter that selects all <systemitem class="systemname">Demo VM</systemitem> nodes. A
	host has to pass all top-level filters to show up. Currently,
	<application>QluMan</application> provides six top-level filters: Hostname,
	HostTemplate, Enclosure, HEADNODE, HEADNODES and ONLINE. Additional ones will be added
	in future versions.
      </para>
      <blockquote>
	<bridgehead xml:id="HostnameFilter">
	  Hostname Filter
	</bridgehead>
	<para>
	  <!--cbox(filter_editor__2_hostnames2.png)-->
	  <!--cbox(filter_editor__add__hostname.png)-->
	  <!--cbox(filter_editor__2_hostnames1.png)-->
	  Adding a Hostname filter opens up a pop-up dialog asking for the hostname or a
	  regular expression to filter for. The input must be a regular expression in
	  <literal>python</literal> syntax and is matched against the beginning of the
	  hostname. If a match against the full hostname is desired then "$" should be added at
	  the end. A ".*" can be added to the front, to match anywhere in the hostname instead
	  of matching against the beginning.
	</para>
	<para>
	  Multiple hostname patterns can be added to a Hostname filter through the context
	  menu. 
	  <note>
	    <para>
	      Note that this is <emphasis role="bold">additive</emphasis>: If a host matches at
	      least one pattern, it will be included in the resulting list.
	    </para>
	  </note>
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="HostTemplateFilter">
	  Host Template Filter
	</bridgehead>
	<para>
	  <!--cbox(filter_editor__hotstemplate__add_template1.png)-->
	  <!--cbox(filter_editor__hotstemplate.png)-->
	  <!--cbox(filter_editor__add_hosttemplate.png)-->
	  <!--cbox(filter_editor__hotstemplate2.png)-->
	  <!--cbox(filter_editor__hotstemplate__add_template2.png)-->
	  Adding a Host Template filter does not pop up a dialog. Instead it adds an empty Host
	  Template filter. This simply selects all hosts with an assigned Host Template. Hosts
	  that do not have a Host Template will not pass this filter. The filter can be made
	  more specific by adding Host Template patterns to it through the context menu. This
	  opens up a pop-up dialog, from where an existing Host Template name can be selected.
	</para>
	<para>
	  The result is a list of hosts, for which the associated Host Template matches the
	  given pattern.  Adding multiple Host Template names is again additive, just like with
	  Hostname patterns.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="EnclosureFilter">
	  Enclosure Filter
	</bridgehead>
	<para>
	  <!--cbox(filter_editor__enclosure.png)-->
	  <!--cbox(filter_editor__add__enclosure.png)-->
	  <!--cbox(filter_editor__enclosure2.png)-->
	  <!--cbox(filter_editor__enclosure__add.png)-->
	  Adding an Enclosure filter also does not bring up a dialog. Like a Host Template
	  filter, it selects all hosts that are part of an enclosure. Unlike the Hostname and
	  Host Template filters though, an Enclosure filter allows for two different
	  specifications: The name <emphasis role="bold">and</emphasis> the type of an
	  enclosure can be matched. Just like Hostname and Host Template filters the Enclosure
	  filter is additive. Adding sub-filters for both the Enclosure name and the Enclosure
	  type will filter hosts that match at least one of those criteria. To filter for hosts
	  that match both, an Enclosure name and an Enclosure type two separate Enclosure
	  filters have to be used, to get the intersection of both filters. The first one to
	  filter the name and the second to filter the type.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="Inverting-a-Filter">
	  Inverting a Filter
	</bridgehead>
	<para>
	  Every filter, sub-filter and pattern can be inverted through the context menu. The
	  context menu for a pattern contains menu entries for both the pattern and the
	  enclosing filter separated by a line. The first <emphasis
	  role="bold">Invert</emphasis> entry will invert the specific pattern that was
	  selected, while the second <emphasis role="bold">Invert</emphasis> will invert the
	  whole filter.
	</para>
	<para>
	  <!--cbox(filter_editor__invert_filter.png)-->
	  <!--cbox(filter_editor__invert_pattern.png)-->
	  <!--cbox(filter_editor__invert.png)-->
	  Besides the obvious, this can also be useful in finding hosts that are not configured
	  correctly. For example, adding an empty Host Template filter and inverting it, will
	  show all hosts without a Host Template. Adding a second filter, that selects all
	  switches, power controllers and other special devices (they usually don't need a Host
	  Template) and also inverting that, results in a list of all hosts, that are neither
	  properly configured nodes (missing Host Template) nor special devices.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="Additive-versus-Subtractive">
	  Additive versus subtractive
	</bridgehead>
	<para>
	  <!--cbox(filter_editor__subtractive.png)-->
	  When constructing a filter, it is important to remember, that all top-level filters
	  are subtractive. A host must pass all top-level filters to show up in the result. On
	  the other hand, all patterns and sub-filters are additive. Matching any one of them
	  within a top-level filter adds the host to the result of that filter. Hence, when
	  subtractive behavior is desired for patterns or sub-filters, each pattern or
	  sub-filter must be added to its own top-level filter. For example, to select all
	  hosts that start with <systemitem class="systemname">beo</systemitem> as well as end
	  on "1" two Hostname filters have to be added.
	</para>
      </blockquote>
    </section>
    <section xml:id="User-Rights-Manage">
      <title>QluMan User and Rights Management</title>
      <para>
	<application>QluMan</application> is <literal>multi-user capable</literal> and provides
	an interface to configure and control users as well as their permissions when they work
	with <application>QluMan</application>. The <application>QluMan</application> users are
	not connected to system users in any way. To simplify permission management, the
	concept of <literal>user roles</literal> can be used. User roles allow to predefine a
	<emphasis role="bold">collection of permissions</emphasis> for
	<application>QluMan</application> operations. Once defined, they can be assigned to a
	user.
      </para>
      <bridgehead xml:id="User-Manage">
	Managing QluMan Users
      </bridgehead>
      <para>
	<!--cbox(users.png)-->
	<!--cbox(users__select.png)-->
	The <literal>admin user</literal> is pre-defined and has the <literal>admin
	role</literal>, meaning all possible rights. Roles for the admin user can not be
	changed, just like the root user in a Linux system always has all rights. When running
	<application>QluMan</application> for the first time, you should set the right email
	address for the admin user.
      </para>
      <para>
	<!--cbox(users__new3.png)-->
	<!--cbox(users__new2.png)-->
	<!--cbox(users__select.png)-->
	<!--cbox(users__new.png)-->
	To create a new user, click <guibutton>New User</guibutton> and enter the name for the
	new user to create it. Then select the user from the drop-down menu and fill out the
	remaining fields. The changes will be saved automatically when <keycap>return</keycap>
	is pressed or the input field looses the focus. New users have no roles assigned to
	them and will have no rights to change anything. They can look but not touch. See <xref
	linkend="Permission-Manage" endterm="Permission-Manage"/> for how to create new roles
	and assign them to the user by checking the respective checkboxes. If the
	<guibutton>New User</guibutton> button is not selectable then the user lacks sufficient
	rights to create new users. The roles buttons will then also be disabled preventing an
	unauthorized user to give himself or others extra roles.
      </para>
      <para xml:id="one-time-token">
	<!--cbox(users__new_auth_token.png)-->
	The new is also created without login credentials, so initially, he can't log
	in. Hence, the next step is to generate a one-time token for the user by clicking
	<guibutton>New Auth Token</guibutton>.  Generating the one-time token may take a little
	to generate while before the <classname>New Auth Token</classname> dialog opens and
	shows a certificate containing the generated one-time token as well as the other login
	informations required to connect to the server. The certificate is protected by an 8
	digit password so that it can be transfered over unencrypted communications channels
	like email or jabber. In such a case the password should be send over a second,
	different, communication channel, e.g. read over the phone. As a special case, when a
	user clicks <guibutton>New Auth Token</guibutton> for itself, the generated token is
	imported into the running client and replaces the current login credentials. A
	reconnect is then triggered forcing the client to generate a new random public/private
	key pair and use the one-time token to authenticate itself to the server. This should
	be used to invalidate the old keys and replace them with fresh ones when a user
	suspects the certificate safe might have been compromised by an attacker.
      </para>
      <para>
	<!--cbox(users__new_auth_token_2.png)-->
	The <classname>New Auth Token</classname> dialog also has 3 usefull buttons at the
	right bottom corner. The <guibutton>Import</guibutton> button allows adding the
	certificate directly to the running client. The use case for this is when creating a
	user account for oneself when working as admin. It is recommendd that for clusters with
	multiple users with admin role that every user has their own user account and the admin
	user is only used to create those.
	<!--cbox(users__new_auth_token__mailed.png)-->
	<!--cbox(users__new_auth_token__saved.png)-->
	The <guibutton>Save</guibutton> button allows saving the certificate into a file and
	the <guibutton>Mail</guibutton> button sends the certificate to the email configured
	for the user. In both cases only the certificate is saved or mailed and the password
	needs to be send separately.
      </para>
      <para>
	For the best security it is recommened to leave any new user without roles until they
	have logged in using the one-time token. That way if the certificate was intercepted it
	has become useless to an attacker. Or if the attacker manages to intercept and use the
	certificate before the real user then the real user won't be able to use it. Meanwhile
	the attacker won't be able to change anything in the cluster.
      </para>
      <note>
	<para>
	  The certificate contains the information about the cluster telling the client how to
	  connect to it and the public key of the <systemitem
	  class="systemname">qlumand</systemitem> server that ensures the client will only talk
	  to the right server and can't be eavesdropped. It also contains a one-time token
	  allowing any client to log in exactly once within the next 48 hours. On the first
	  login with a correct one-time token the clients public key (generated randomly and
	  unique to use cluser and user) is stored by the server and used to authenticate the
	  user in the future. The clients and servers public and private keys are also used
	  when connecting to safely exchange session keys for encryption with perfect forward
	  security.
	</para>
      </note>
      <para>
	<!--cbox(users__delete2.png>-->
	<!--cbox(users__delete.png>-->
	An user other than admin can be deleted by clicking the <guibutton>Delete
	User</guibutton> button. Just like the <guibutton>New User</guibutton> button it is
	only enabled if the current user has sufficient rights.
      </para>
      <bridgehead xml:id="Permission-Manage">
	Managing User Roles/Permissions
      </bridgehead>
      <para>
	The <application>QluMan</application> server performs <emphasis role="bold">many
	individual rights</emphasis> checks, before it allows/performs an operation. Many of
	those correspond directly to a specific window in the GUI, giving the user the right to
	alter settings in that window. For example, the right to configure UnionFS groups
	corresponds directly to operations available from the <literal>UnionFS Groups</literal>
	window under <guimenuitem>Manage Configs</guimenuitem>-><guimenuitem>UnionFS
	Groups</guimenuitem>. Others govern the right to specific actions or to alter specific
	properties. For example, the right to configure OpenSM on hosts enables the user to
	add, alter or delete the <literal>OpenSM Ports</literal> and <literal>OpenSM
	Options</literal> property of hosts in the <classname>Enclosure View</classname>.
      </para>
      <para>
	The rights are grouped into 4 categories: <literal>Admin rights</literal> covers rights
	with global impact and root access to nodes, <literal>Booting</literal> covers all
	settings that affect how nodes will boot, <literal>Services</literal> covers the
	configuration of daemons and <literal>Host Config</literal> covers the general
	configuration of hosts.
      </para>
      <para>
	<!--cbox(roles__manager.png)-->
	<!--cbox(roles__new.png)-->
	<!--cbox(roles__empty.png)-->
	Creating and editing roles is simple. Click <guibutton>New</guibutton> to create a new
	role, fill in a name and description for it and click <guibutton>OK</guibutton>. To
	change the rights associated with a role, first select it using the dropdown menu at
	the top. Next click the checkmark boxes to the left of the rights you want to change,
	grant or remove from the role. Click <guibutton>Save</guibutton> to save the changes or
	<guibutton>>Undo</guibutton> to reset the rights to the last saved settings.
      </para>
    </section>
    <section xml:id="Look-And-Feel">
      <title>Customizing the Look&amp;Feel</title>
      <para>
	There are three aspects of <application>QluMan's</application> appearance that can be
	customized: Fonts, colors and widget style. Since QluMan is a QT application, it's
	Look&amp;Feel can be controlled with <link
	xlink:href="http://www.kde.org/___blank___">KDE</link> tools. Select the
	<guimenuitem>Manage Cluster->Preferences</guimenuitem> menu entry to bring up the KDE
	<classname>System Settings</classname> dialog. Now click on the <classname>Application
	Appearance</classname> icon and you'll have the options to modify fonts, colors and
	style.
      </para>
      <bridgehead xml:id="Look-And-Feel-Fonts">
	Fonts
      </bridgehead>
      <para>
	When you click on the <guiicon>Fonts</guiicon> icon, you'll see a list of different
	font identifiers for which you can change the font settings.  The relevant identifiers
	to be adjusted for <application>QluMan</application> are <literal>General</literal>,
	<literal>Menu</literal> and <literal>Window Title</literal>. Changing one of the values
	and clicking the <guibutton>Apply</guibutton> button changes the corresponding font on
	the fly.
      </para>
      <bridgehead xml:id="Look-And-Feel-Colors">
	Colors
      </bridgehead>
      <para>
	<!--cbox(system_settings_colors.png)-->
	Click on the <guiicon>Colors</guiicon> icon and choose the
	<guimenuitem>Colors</guimenuitem> tab. There you can adjust the color of the different
	elements of the <application>QluMan GUI</application>. You can narrow down the color
	identifiers to the ones affecting particular GUI elements by choosing a specific color
	set with the corresponding pull-down menu. Changing one of the values and clicking the
	<guibutton>Apply</guibutton> button changes the corresponding color on the fly.
      </para>
      <bridgehead xml:id="Look-And-Feel-Manual">
	Manual
      </bridgehead>
      <para>
	If you're using <firstterm>KDE4</firstterm> on you're desktop, instead of configuring
	using the <classname>System Settings</classname> dialog, you can also move
	<filename>/root/.kde/share/config</filename> to
	<filename>/root/.kde/share/config.bak</filename> and copy your personal configured
	<filename>.kde/share/config</filename> directory to
	<filename>/root/.kde/share</filename>. As long as you're not using any non-standard KDE
	themes, this should just apply the favorite desktop settings you're familiar with to
	<application>QluMan</application> (restart of QluMan GUI required).
      </para>
      <bridgehead xml:id="Look-And-Feel-Widget-Style">
	Widget Style
      </bridgehead>
      <para>
	<!--cbox(qtconfig.png)-->
	Changing the widget style can be a little more involved. First you need to start the QT
	configurator and choose a GUI style (default is QtCurve).
	<screen>
<prompt>0 root@cl-head ~ #</prompt>
<command>ssh -X root@servername qtconfig</command>
	</screen>
      </para>
      <para>
	When you're done, select
	<guimenuitem>File</guimenuitem>-><guimenuitem>Save</guimenuitem> and you'll already see
	the changes. After this you can exit qtconfig. If you want further customization of the
	widget style (note that only some styles are configurable, among them QtCurve), you can
	now go back to the <classname>Application Appearance</classname> Dialog (see above),
	click on the <guiicon>Style</guiicon> icon, choose the
	<!--cbox(system-settings-style.png)-->
	style you've selected in qtconfig as <literal>Widget style</literal> and press the
	<guibutton>Configure...</guibutton> button. You'll see a large number of options for
	customization. When you're satisfied with your modifications, press the <guibutton>OK</guibutton> button and
	finally the <guibutton>Apply</guibutton> button of the <classname>Style - System Settings</classname> window. Note, that you will
	see the resulting changes only after performing some actions (pressing a button, etc.)
	in the <application>QluMan GUI</application>.
      </para>
      <para>
	To have more options for changing the widget style from the default of QtCurve, you can
	install additional kde-style packages (.e.g <package>kde-style-oxygen</package>) on the
	head-node.
      </para>
    </section>
  </chapter>
  <xi:include href="Revision_History.xml"/>
  <index />
</book>
