<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE book [
<!ENTITY % BOOK_ENTITIES SYSTEM "QluMan_Guide.ent">
%BOOK_ENTITIES;
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "/usr/share/xml/docbook/schema/dtd/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude">

  <xi:include href="Book_Info.xml"/>
  <xi:include href="Preface.xml"/>
  <xi:include href="Introduction.xml"/>
  <xi:include href="Cluster-Connections.xml"/>
  <xi:include href="Global-Cluster-Settings.xml"/>
  <xi:include href="Enclosures.xml"/>
  <xi:include href="Adding-Hosts.xml"/>
  <xi:include href="Config-Classes.xml"/>

  <chapter xml:id="chap-the-rest">
    <title>The rest</title>
    <section xml:id="Other-Configs">
      <title>Other Configs</title>
      <bridgehead xml:id="Qlustar-OS-Images">
	Qlustar OS Images
      </bridgehead>
      <para>
	<!--cbox(file: qlustar_images/main.png)-->
	Qlustar OS images can be defined and configured in the <classname>Qlustar
	Images</classname> dialog accessible via <guimenuitem>Manage
	Configs</guimenuitem>-><guimenuitem>Qlustar Images</guimenuitem>. Each image has a
	unique name, a flavor (currently only <classname>precise</classname>), a version, a
	<xref linkend="UnionFS-Chroots" endterm="UnionFS-Chroots"/> and one or more image
	modules.
      </para>
      <blockquote>
	<bridgehead>
	  Image Versioning
	</bridgehead>
	<para>
	  Currently available image versions are 9, 9.0 (both meta-versions) and 9.0.0. Note,
	  that selecting meta-versions has implications on the update process. They allow
	  tracking the newest x.y (x.y.z) releases automatically. Example: If you have
	  installed version 9 of the modules, you will currently get the 9.0 (most recent 9.y)
	  versions, but when 9.1 will be
	  <!--cbox(file: qlustar_images__modules.png)-->
	  available, <code>apt-get dist-upgrade</code> will update to 9.1 versions
	  automatically. So with this choice, updates will usually include larger changes,
	  since new <emphasis role="bold">feature</emphasis> releases (like 9.1) will
	  automatically be installed. Similar, if you have selected the 9.0 version (currently
	  default after a fresh installation) you will currently get 9.0.0 (most recent 9.0.z
	  version) and <code>apt-get dist-upgrade</code> will update the modules/images to
	  9.0.1 automatically once available. So this choice will update to new <emphasis
	  role="bold">maintenance</emphasis> releases automatically. The most conservative
	  choice would be to explicitly select a x.y.z version (currently 9.0.0), since then
	  images will only receive bug fix updates without explicitly changing the version in
	  <productname>Qlustar</productname>. See also the discussion in the general <link
	  xlink:href="https://qlustar.com/book/docs/qlustar-update-procedure/___blank___">
	  Qlustar Update Guide</link>
	</para>
      </blockquote>
      <blockquote>
	<bridgehead>
	  Image Properties
	</bridgehead>
	<para>
	  <!--cbox(file: qlustar_images__new.png)-->
	  A couple of images are pre-defined during the installation process. The dialog shows
	  the images sorted by their names. Expanding an entry shows its configuration and
	  allows to select a UnionFS chroot via the drop-down menu. Each image must contain at
	  least the core module. Additional modules can be added or removed using the context
	  menu when hovering over an entry. Only modules that are not already chosen are
	  available for selection.
	</para>
	<para>
	  New images can be added through the context menu or by pressing the
	  <guibutton>New</guibutton> button at the bottom of the dialog. Like before, you
	  should then enter the name for the new config, choose a UnionFS group and optionally
	  provide a description for the new image. Existing images can be removed via the
	  context menu.
	</para>
      </blockquote>
      <bridgehead>
	NIS hosts
      </bridgehead>
      <para>
	<!--cbox(file: nis/host_header.png)-->
	NIS (Network Information System) is used to manage hostname resolution within the
	cluster. For all hosts that are managed within <application>QluMan</application>
	itself, a corresponding NIS entry is created automatically. However, administrators
	might want to add other hosts external to the cluster to the NIS database as well. To
	achieve this, the creation of the NIS hosts database is split into a header part that
	can be freely edited by the admin, and a part that is auto-created with the hosts
	managed by <application>QluMan</application>. To edit the header part, choose
	<guimenuitem>Manage Configs</guimenuitem>-><guimenuitem>NIS Host Header</guimenuitem>
	from the main menu. The top part of the window popping up can then freely be
	edited. Note that entries for the head-node are automatically created upon installation
	and should remain unchanged unless one of the head-nodes IP changes. The resulting NIS
	hosts file can then be previewed and written to disk by pressing the corresponding
	dialogs at the bottom of the dialog. Upon writing the file, the NIS database is
	automatically rebuilt on the NIS master server.
      </para>
      <bridgehead>
	SSH host files
      </bridgehead>
      <para>
	<!--cbox(file: ssh_hosts__known.png)-->
	To simplify ssh remote logins to cluster nodes, three ssh configuration files are
	provided and managed by <application>QluMan</application>: (a)
	<filename>ssh_known_hosts</filename> (holds ssh host keys of cluster nodes), (b)
	<filename>shosts.equiv</filename> (enables login without password between machines
	within the cluster) and (c) <filename>authorized_keys</filename>, which is used to
	allow password-less root login to nodes with the specified ssh public keys. The first
	two config files consist of a configurable header part, where additional hosts can
	freely be entered and an auto-generated part for the hosts managed by
	<application>QluMan</application>. The last one just has the configurable part. Ssh
	host info for the head-node and a possibly configured frontend-node are automatically
	inserted during the installation process.
      </para>
      <para>
	<!--cbox(file: ssh_hosts__authorized_keys.png)-->
	<!--cbox(file: ssh_hosts__equiv.png)-->
	Management of the three configs is similar to the <classname>NIS hosts</classname>
	dialog: To edit the header part of either config, select <guimenuitem>Manage
	Configs</guimenuitem>-><guimenuitem>SSH Configs</guimenuitem> from the main menu. Then
	choose the config to work on by using the drop-down menu at the bottom left. The top
	part of the window popping up can then freely be edited. Finally, the resulting ssh
	host files can be previewed and written to disk by pressing the corresponding dialogs
	at the bottom of the dialog.
	<note>
	  <para>
	    There is no preview of the <filename>authorized_keys</filename> file, as this is
	    automatically written during the boot phase on hosts, that are not head-nodes.
	  </para>
	</note>
      </para>
      <bridgehead xml:id="UnionFS-Chroots">
	UnionFS Chroots
      </bridgehead>
      <para>
	In most practical cases, a <productname>Qlustar</productname> image should be
	configured with an associated UnionFS chroot. Exceptions are single purpose images
	e.g. for Lustre servers. By design, images are stripped down to the functionality
	(programs) that is most often needed on a compute/storage node. This keeps them small
	while still providing fast, network-independent access to programs/files typically
	used.
      </para>
      <para>
	To complement the image and provide the full richness of the packages/programs
	available in the chosen Linux distribution, the UnionFS chroot (holding a full
	installation of e.g. Ubuntu) is exported via NFS by one of the head-nodes and
	technically <emphasis role="bold">merged below</emphasis> the content of the
	<classname>Qlustar OS image</classname>. In practice, this means that all files
	belonging to the chroot will be available on the nodes configured to use it, but if a
	file/program is also in the node's image, that one will be used. Hence, this method
	combines the <emphasis role="bold">compactness and speed</emphasis> of the imaging
	approach with the <emphasis role="bold">completeness</emphasis> of a full OS
	installation to give you the best of all worlds.
      </para>
      <para>
	<!--cbox(file: manage_chroots/main.png)-->
	<!--cbox(file: menu-manage_cluster__manage_chroots.png)-->
	The chroot associated with a Qlustar image is easily selectable as explained <xref
	linkend="Qlustar-OS-Images" endterm="Qlustar-OS-Images"/>. Management of the chroots
	themselves is possible via the <classname>Manage Chroots</classname> dialog which is
	accessible via the main menu <guimenuitem>Manage
	Cluster</guimenuitem>-><guimenuitem>Manage Chroots</guimenuitem>. It provides a number
	of actions related to chroots. Manipulation of the contents of chroots is explained
	<link xlink:href=
	"https://qlustar.com/book/docs/first-steps#Adding-Software">elsewhere</link>.
      </para>
      <para>
	<!--cbox(file: manage_chroots__select_chroot.png)-->
	To <emphasis role="bold">specify a chroot to operate on</emphasis>, select it via the
	corresponding pull-down menu. This will show its description, as well as its properties
	like the NFS server that hosts it, the filesystem path on the server, the flavor (edge
	platform, precise/wheezy/...)  and the version of the
	<productname>Qlustar</productname> feature release (always being of the form x.y, e.g
	8.1).
      </para>
      <para>
	<!--cbox(file: manage_chroots__new2.png)-->
	<!--cbox(file: manage_chroots__new1.png)-->
	When <emphasis role="bold">generating a new chroot</emphasis>, a name for the chroot
	must be specified and optionally a description of its purpose. Furthermore, you can
	select an NFS server where the chroot will be located (currently only one option), a
	flavor (aka edge platform) and <productname>Qlustar</productname> version. Finally you
	have the possibility to select <classname>Qlustar tasks</classname>. These are topic
	package bundles, each consisting of a collection of packages relevant to a certain
	field of HPC applications. Pressing the <guibutton>OK</guibutton> button then starts
	the generation of the chroot. You can follow the rather lengthy process (count a couple
	of minutes) in its own window.
      </para>
      <para>
	<!--cbox(file: manage_chroots__edit.png)-->
	<!--cbox(file: manage_chroots__clone2.png)-->
	<!--cbox(file: manage_chroots__clone1.png)-->
	<emphasis role="bold">Cloning an existing chroot</emphasis> is mostly useful when you
	want to test an upgrade to a new release or for other tests. Pressing the
	<guibutton>Clone</guibutton> button opens a sub-window in which you can specify the
	name of the new cloned chroot and optionally a description of its purpose. Pressing the
	<guibutton>OK</guibutton> button then starts the cloning process. You can again watch
	it in its own window. Editing a chroot let's you edit it's description.
      </para>
      <para>
	<!--cbox(file: manage_chroots__remove3.png)-->
	<!--cbox(file: manage_chroots__remove2.png)-->
	<!--cbox(file: manage_chroots__remove1.png)-->
	<emphasis role="bold">Removal of a chroot</emphasis> by pressing the
	<guibutton>Remove</guibutton> button first asks you for a final confirmation. If you
	then press the <guibutton>Delete</guibutton> button, the chroot will be removed
	provided it is not still in use by a Qlustar image. If it is still in use, a list of
	images that are associated with the chroot is given. You would then first have to
	reconfigure these images to use another chroot before trying to remove again. <emphasis
	role="bold">Renaming of a chroot</emphasis> is not supported directly. To rename you'd
	have to clone the original chroot giving the clone the new desired name and afterwards
	remove the old chroot.
      </para>
      <bridgehead xml:id="Configuring-IB">
	Infiniband network
      </bridgehead>
      <para>
	For most practical purposes, Infiniband (IB) adapters need to be configured with an IP
	address (IPoIB) just like Ethernet adapters. If you have chosen to configure an IB
	network during installation, this section is mostly about how to review or change the
	initial
	<!--cbox(file: network_config__infiniband.png)-->
	settings. If not, IB first has to be activated in the <xref
	linkend="Configuring-the-Network"/> dialog. An IB Network address IP and netmask can
	then be chosen. The Infiniband network must not collide with the Cluster (Ethernet) or
	IPMI network. This is prevented automatically in the settings dialog. The Infiniband IP
	of each host is computed by mapping the host part of its Cluster Network IP to the IB
	Network. Example: IP Cluster Network 192.168.52.100 - IP IB network
	192.168.53.100. Note, that this mechanism requires the IB netmask to be at least as
	large as the Cluster Network netmask. Hence, smaller values won't be selectable.
      </para>
      <para>
	<!--cbox(file: hardware_property_set__ib.png)-->
	To actually have a node's IB adapter be configured during the boot process, additional
	steps are necessary. It is not uncommon, that a cluster consists of hosts with IB and
	hosts without. Therefore, the pre-defined hardware property <parameter>IB
	Adapter</parameter> with a value of <parameter>true</parameter> must be assigned to a
	host, to explicitly enable IB for it. This is done most conveniently, by adding this
	property to the Hardware Property Set(s) used in the Host Template(s) for nodes with
	IB. If this assignment exists, Infiniband modules will be loaded and IP-over-IB will be
	configured during the boot process of the corresponding nodes with the IP mapping
	described above.
      </para>
      <blockquote>
	<bridgehead>
	  Activating/configuring OpenSM
	</bridgehead>
	<para>
	  In an IB fabric, at least one node (or switch) has to run a subnet manager to manage
	  the routing tables. Qlustar provides <application>OpenSM</application> for this
	  task. If the head-node is also part of the IB network, it's usually best to configure
	  it to run OpenSM. This might have
	  <!--cbox(file: opensm__port_all.png)-->
	  been chosen during installation, in which case there is nothing more to be done. If
	  not, you have the option to run OpenSM on ordinary nodes too. In this case, it is
	  advisable to run OpenSM on two or three nodes (not more) for redundancy reasons. It
	  is therefore best, to configure this directly for the chosen hosts, rather than using
	  a Host Template or generic property set.  After selecting the host or hosts where
	  OpenSM should run in the Enclosure View, open the context menu and select
	  <guimenuitem>Set Generic Property</guimenuitem>-><guimenuitem>OpenSM
	  Ports</guimenuitem>-><guimenuitem>ALL</guimenuitem>. The next time the hosts boots,
	  the OpenSM daemon will be started on all its Infiniband ports.
	</para>
	<para>
	  <!--cbox(file: opensm__port_create_1.png)-->
	  <!--cbox(file: opensm__port_1.png)-->
	  If a host has more than one IB port, OpenSM can also be configured to run only on a
	  specific port instead of all of them. The port can be specified by its number or by
	  its unique ID. As this is an uncommon configuration and the unique ID is unknown
	  beforehand, there is no preset value for this. To create a new value, first select an
	  existing value, e.g. ALL, for the generic property <literal>OpenSM
	  Ports</literal>. You can then edit the value in the <classname>Generic
	  Properties</classname> box of a host. Editing the line and pressing
	  <keycap>return</keycap> will create the new value. Beware that this will only affect
	  one shown host. To assign the new value to other hosts, select them and then change
	  the OpenSM Ports property through the context menu.
	</para>
	<para>
	  <!--cbox(file: opensm__option_edit.png)-->
	  <!--cbox(file: opensm__option_add.png)-->
	  In some circumstances it might be necessary to run OpenSM with extra options. This
	  can also be configured via generic properties. The only preset value is the empty
	  string, so you need to create a new value for the options you require. First add the
	  empty value of the generic property <classname>OpenSM Options</classname> to one
	  host. Edit the value to your requirements and press <keycap>return</keycap> to create
	  it. Finally add/change the OpenSM Options generic property to all relevant hosts.
	</para>
      </blockquote>
      <bridgehead>
	IPMI settings
      </bridgehead>
      <para>
	<!--cbox(file: network_config__ipmi.png)-->
	Configuring IPMI is similar to Infiniband and also involves multiple steps, because
	there are a number of options to set. If you have chosen to configure an IPMI network
	during installation, a larger part of this section is about how to review or change the
	initial settings. If not, IPMI first has to be activated in the <xref
	linkend="Configuring-the-Network"/> dialog. There you can set the IPMI Network address
	IP and netmask. The IPMI address of a host is then determined with the same mapping as
	<xref linkend="Configuring-IB" endterm="Configuring-IB"/> and the same restrictions for
	the choice of netmask apply.
      </para>
      <para>
	<!--cbox(file: hardware_property_set__ipmi.png)-->
	Often not all nodes in a cluster have IPMI. Therefore, in
	<application>QluMan</application> per default no host is configured to setup IPMI,
	unless it is assigned the hardware property <literal>IPMI Adapter</literal> with a
	value of <parameter>true</parameter>. The easiest way to achieve this, is to add the
	<literal>IPMI Adapter</literal> property to the Hardware Property Set(s) used in the
	Host Template(s) for the nodes with IPMI. With this assignment, a node is ready for
	monitoring its temperature and fan speeds.
      </para>
      <para>
	<!--cbox(file: generic_property_set__ipmi_channel_add.png)-->
	<!--cbox(file: generic_property_set__ipmi_initialize_add.png)-->
	Enabling IPMI nodes for remote control involves two more settings. The first one is the
	generic property <parameter>Initialize IPMI</parameter>. Per default the settings of
	the IPMI cards are not touched by <productname>Qlustar</productname>. However, while
	the <parameter>Initialize IPMI</parameter> generic property is assigned and set to
	<parameter>true</parameter>, the IPMI card settings of the corresponding host will be
	reset every time it boots. Changing the value of this property to
	<parameter>true</parameter> and after booting back to <parameter>false</parameter>
	allows a one-time setup of the cards properties.
      </para>
      <para>
	<!--cbox(file: generic_property_set__ipmi_channel_edit.png)-->
	The second generic property is the <parameter>IPMI Channel</parameter> to use. Per
	default channel 1 is used and this is the only preset value for the property. If you
	need to use a different channel, first add the generic property <parameter>IPMI
	Channel</parameter> to the <classname>Generic Property Set</classname> (or to a host
	directly) and then edit the value.
      </para>
    </section>
    <section xml:id="Comand-execution">
      <title>RXEngine / Remote Execution Engine</title>
      <para>
	<!--cbox(file: execute__overview.png)-->
	<application>QluMan</application> provides a powerful <classname>remote command
	execution engine</classname>, that allows to run shell commands on any number of hosts
	in <emphasis role="bold">parallel</emphasis> and analyze their output/status in
	<emphasis role="bold">real-time</emphasis>. Commands fall into two categories:
	<literal>Pre-defined commands</literal> and <literal>custom commands</literal>.
      </para>
      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      The command can be a single command or a series of commands in shell syntax.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The hosts are specified in <literal>Hostlist format</literal> or through a
	      <literal>filter</literal>, so that even large groups can be represented by a
	      short string.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The commands run in parallel on all hosts.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The network connection used for remote execution is both <emphasis
	      role="bold">encrypted and authenticated</emphasis>. It employs the same
	      high-speed/high-security elliptic-curve cryptography that is used for the
	      connection between the <application>QluMan server</application> and the
	      <application>QluMan GUI</application>.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The output is <emphasis role="bold">analyzed</emphasis> and updated in short
	      intervals during the execution phase.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Hosts with equal output are <emphasis role="bold">grouped</emphasis> together to
	      reduce the noise.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The output can further be <emphasis role="bold">filtered</emphasis> by the return
	      code of the command and by (de)selecting <literal>stdout</literal> and/or
	      <literal>stderr</literal>.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
      <bridgehead>
	Executing a pre-defined command
      </bridgehead>
      <para>
	<!--cbox(file: execute_predefined2.png)-->
	<!--cbox(file: execute_predefined1.png)-->
	<!--cbox(file: enclosure_view__execute_predefined.png)-->
	Pre-Defined commands can be created using the <classname>Command Editor</classname>
	(see <xref linkend="CommandEditor"/> for details). To execute a pre-defined command,
	open the pull-down menu of the <guibutton>Execute button</guibutton> at the bottom of
	the <classname>Enclosure View</classname> and select an entry. This opens a new
	<classname>Command Execution</classname> window for pre-defined commands. At the very
	top of it, the selected pre-defined command is shown. It can be changed if
	required. Below that is a list of arguments, the selected command
	accepts. <guilabel>Execute on</guilabel> is always present showing where the command
	will be executed. If defined, additional arguments of the command are displayed
	underneath. Further below, the final command is shown, with its arguments inserted at
	the right places. The command will be executed upon clicking the
	<guibutton>Execute</guibutton> button.
      </para>
      <para>
	<!--cbox(file: execute_predefined4.png)-->
	<!--cbox(file: execute_predefined3.png)-->
	<!--cbox(file: enclosure_view__execute_predefined2.png)-->
	Arguments to a pre-defined command can be set fixed to a <xref
	linkend="HostFilterEditor"/> , in which case the filter and its resulting hostlist are
	shown as plain text and can not be edited. Optionally, specification of arguments in
	Hostlist format may also be left up to the user. In that case, a combo-box is shown,
	followed by the evaluation of the specified input shown as plain text. When hosts were
	selected in the <classname>Enclosure View</classname>, the combo-box will contain the
	hostlist corresponding to the selection as default. The text can be edited directly or
	a filter can be chosen from the dropdown menu. Any argument starting with "%" is
	assumed to be a filter. If this is not intended, the "%" must be escaped by another
	"%", but only at the start of an argument. For more details about specifying arguments
	in pre-defined commands see <xref linkend="CommandEditor"/>.
      </para>
      <bridgehead>
	Executing a custom command
      </bridgehead>
      <para>
	<!--cbox(file: execute/main.png)-->
	<!--cbox(file: enclosure_view__execute.png)-->
	To execute a custom command, open the pull-down menu of the <guimenu>Execute
	button</guimenu> at the bottom of the <classname>Enclosure View</classname> and select
	custom command from the menu. This opens a new blank <classname>Command
	Execution</classname> window.
	<note>
	  <para>
	    The initial hostlist is empty in the screenshot examples, since no hosts where
	    selected in the <classname>Enclosure View</classname>
	  </para>
	</note>.
      </para>
      <para>
	<!--cbox(file: execute__past_command.png)-->
	<!--cbox(file: execute__update.png)-->
	<!--cbox(file: execute__selected.png)-->
	In case hosts were selected in the <classname>Enclosure View</classname> before
	clicking the <guibutton>Execute</guibutton> button, a hostlist representing these hosts
	will be present in the <classname>Command Execution</classname> window. This allows
	<emphasis role="bold">easy selection of hosts</emphasis> to run a command on by <link
	linkend="sec-Host-Selections">selecting them</link> in the <classname>Enclosure
	View</classname>. The hostlist can also be updated at a later time from the currently
	selected hosts in the Enclosure View by clicking the <guibutton>Update</guibutton>
	button. This makes it simple, to run the same command on different sets of hosts. When
	a command is executed, it is added to the <literal>history</literal> and can be
	accessed again later through the pull-down menu. This allows rerunning recently used
	commands without having to retype them every time.
	<note>
	  <para>
	    Note, that the history is stored in the users home directory, hence every user has
	    his own. The preferred way to manage frequently used commands is by pre-defining
	    them (explained <xref linkend="CommandEditor"/>).
	  </para>
	</note>
      </para>
      <bridgehead>
	Running Commands / Interpreting their Output
      </bridgehead>
      <para>
	<!--cbox(file: execute__command.png)-->
	Once the hostlist is added, a command can simply be run by entering it in the command
	box and hitting the <guibutton>Execute</guibutton> button. It will then start to run in
	parallel on all listed hosts and the command output will be collected. Periodically, in
	short but increasing intervals, the <emphasis role="bold">output will be
	sorted</emphasis>> and displayed. Hence, for short running programs you will see it
	immediately. Due to the increasing display intervals, long running and noisy commands
	won't cause constant flickering of the output, allowing you to more easily follow it.
      </para>
      <bridgehead>
	Command State
      </bridgehead>
      <para>
	<!--cbox(file: execute__df.png)-->
	After the <guibutton>Execute</guibutton> button has been pressed, all hosts will start
	in the <literal>Pending state</literal>. Once a host confirms that it has started its
	command, it will change to the <literal>Running state</literal>. When the command
	concludes, the state becomes one of <literal>Failed</literal>,
	<literal>Errors</literal> or <literal>Success</literal>. If the command exited with a
	return code other than 0, the host will enter the <literal>Failed</literal> state. If
	the command exited with a return code of 0, but produced output on
	<literal>stderr</literal>, it will enter the <literal>Errors</literal>
	state. Otherwise, it enters the <literal>Success</literal> state.
      </para>
      <para>
	<!--cbox(file: execute__killed.png)-->
	<!--cbox(file: execute__pending.png)-->
	In the screenshot example, the hosts <systemitem class="systemname">sn-1</systemitem>
	and <systemitem class="systemname">sn-2</systemitem> were down, so they remained in the
	<literal>Pending</literal> state. By clicking the <guibutton>Pending</guibutton>
	button, a hostlist of the pending hosts is displayed. The <application>QluMan
	server</application> will start the command on those hosts, when they become online
	again. If you do not want that to happen, or if the command does not terminate on its
	own, then the <guibutton>Kill</guibutton> button allows you to stop the command.  A
	killed command counts as failed, so <systemitem class="systemname">sn-1</systemitem>
	and <systemitem class="systemname">sn-2</systemitem> now enter that state. The command
	output also reflects that the command was killed.
      </para>
      <bridgehead>
	Hosts and Groups
      </bridgehead>
      <para>
	<!--cbox(file: execute_group.png)-->
	Hosts executing a command are not only grouped by their execution state, the command
	output produced by the different hosts is also <emphasis role="bold">analyzed and
	compared</emphasis> to each other. Hosts with identical output are put into a
	group. Their output is only displayed once, prefixed with the hostlist representing the
	hosts in each group. For a quick overview, the number of hosts and groups is also
	displayed below each state button. In the screenshot example, two hosts (<systemitem
	class="systemname">sn-1</systemitem> and <systemitem
	class="systemname">sn-2</systemitem>) have failed, because they where offline and the
	command was killed before starting. The output of both was identical, so they form one
	group. Similar, one host (<systemitem class="systemname">ql-head-pr-t</systemitem>)
	completed the command successfully and builds its own group.
      </para>
      <para>
	The <guibutton>S</guibutton> buttons next to the numbers add or remove the hosts in
	each state to form a new hostlist. Press the button to include the corresponding hosts
	and press it once more to exclude them again. This is convenient, e.g. to quickly
	select only the hosts for which a command failed: Analyze the errors and later relaunch
	with an adjusted command. Another example: Select only the successful hosts to run a
	follow-up command etc.
      </para>
      <bridgehead>
	Filtering by stdout and stderr
      </bridgehead>
      <para>
	<!--cbox(file: execute__errors.png)-->
	Commands usually output regular text to <literal>stdout</literal> and warnings as well
	as errors to <literal>stderr</literal>. In the latter case, the command ends up in the
	<literal>Errors</literal> state, because this is usually something that needs further
	inspection. The screenshot example prints two lines, one to <literal>stderr</literal>
	and one to <literal>stdout</literal>. Unfortunately Unix does not enforce any order
	between output to <literal>stdout</literal> and <literal>stderr</literal>. Therefore,
	as in this example, it can happen, that a small delay between the command output and
	reading from the file descriptors causes the order to slightly change.
      </para>
      <para>
	<!--cbox(file: execute_stderr.png)-->
	<!--cbox(file: execute__stdout.png)-->
	Some commands produce a lot of output. Error messages are then easily overseen in
	between the lines. Similarly a command might report a lot of harmless errors, that hide
	the interesting output going to <literal>stdout</literal>. To simplify an analysis of
	the command output for such cases, the two buttons <guibutton>stdout</guibutton> and
	<guibutton>stderr</guibutton> at the bottom of the window allow <emphasis
	role="bold">toggling the visibility</emphasis> of <literal>stdout</literal> and
	<literal>stderr</literal> output selectively on and off.
      </para>
      <bridgehead>
	Passing input to a command
      </bridgehead>
      <para>
	<!--cbox(file: execute__input.png)-->
	Sometimes it is necessary to pass some input to a command. This can be done by clicking
	the <guibutton>Input</guibutton> button near the top. Another text box will then be
	added to the window and will allow to specify, what should be passed to
	<literal>stdin</literal> of the command on each host. <!--FIXME: rewrite when
	implemented In future version the Browse button will allow selecting a file to be used
	as stdin. -->
      </para>
      <bridgehead>
	Command Syntax
      </bridgehead>
      <para>
	Commands will be interpreted/executed by the <literal>BASH</literal> shell on every
	host matching the hostlist. The full <literal>BASH</literal> syntax is
	supported. Redirection of output to files, as in the last example, and working with
	variables works as expected. Please refer to the <literal>BASH</literal> documentation
	(e.g. <code>man bash</code>) for more details.
      </para>
    </section>
    <section xml:id="CommandEditor">
      <title>Command Editor</title>
      <para>
	<!--cbox(file: command_editor__ls.png)-->
	<!--cbox(file: command_editor/main.png)-->
	The <classname>command editor</classname> shows all the pre-defined commands in a tree
	view on the left. A number of useful commands are already defined by default. Selecting
	a command shows its definition on the right-hand side, where it can also be
	edited. Every command has a unique name/alias under which it appears in the tree view
	on the left, the execute menu in the <classname>Enclosure View</classname> and in the
	drop down menu of the pre-defined commands execution window. In the future, it will
	also be possible to limit commands to specific user roles, but for now all commands are
	unrestricted. A user either has rights to execute any pre-defined commands or
	none. Below the role selector, the command itself is defined.
      </para>
      <bridgehead xml:id="CommandEditor-defining">
	Defining or editing a command
      </bridgehead>
      <para>
	<!--cbox(file: command_editor__new2.png)-->
	<!--cbox(file: command_editor__new1.png)-->
	<!--cbox(file: command_editor__rename.png)-->
	To define a new command, select <guimenuitem>New Command</guimenuitem> from the context
	menu. The new command will be created in the group, where the context menu was opened
	or in the root, if the mouse is outside of any group. Initially, the command will have
	no definitions.
      </para>
      <para>
	To edit a command, it needs to be selected first. Then its definitions will be shown on
	the right-hand side. The name/alias of a command can be edited by clicking in the text
	box at the top and entering the new name. The check-box to the right of the name
	indicates, whether your name is valid. Press enter, to save the new name and the
	check-box will become fully checked again. To undo editing, simply reselect the command
	in the tree view.
      </para>
      <para>
	<!--cbox(file: command_editor__execute_on2.png)-->
	<!--cbox(file: command_editor__execute_on.png)-->
	A command can be executed on any host or set of hosts in the cluster. The
	<guilabel>Execute on</guilabel> field governs how that host or set of hosts is
	constructed. The default is <parameter>User input</parameter>. This means, the user
	will have to choose the hostlist, where the command will run, at the time, when it will
	be executed. Alternatively, the hostlist of the command can be preset by selecting one
	of the filters from the dropdown menu. If a filter is selected, the hostlist, it
	currently evaluates to, is displayed below it.
      </para>
      <para>
	<!--cbox(file: command_editor__edit2.png)-->
	<!--cbox(file: command_editor__edit.png)-->
	Editing the command itself may take a while. To avoid conflicts from concurrent editing
	attempts by different <application>QluMan</application> users, only one person can edit
	a command at a time. To start the editing process, click the
	<guibutton>Edit</guibutton> button at the bottom. After that, changes to the command
	can be entered. Commands will be interpreted/executed by the <literal>BASH</literal>
	shell on every host matching the hostlist. The full BASH syntax is
	supported. Redirection of output to files and working with variables works as
	expected. Please refer to the BASH documentation (e.g. <code>man bash</code>) for more
	details. There is one exception to this: A "%" character followed by a number specifies
	additional arguments for the command, as explained in more detail below.
      </para>
      <para>
	<!--cbox(file: command_editor__edit5.png)-->
	<!--cbox(file: command_editor__edit4.png)-->
	<!--cbox(file: command_editor__edit3.png)-->
	Sometimes it is necessary, to pass some input to a pre-defined command. This can be
	done by clicking the <guibutton>Input</guibutton> check-box. It will bring up an input
	text-box, where the desired input text can be entered.
      </para>
      <para>
	To finish editing the command, click the <guibutton>Save</guibutton> button at the
	bottom. This actually saves the command text and input, if any, in the database and
	releases the lock on the command. This also scans the command text for argument
	placeholders and updates the entries in the <classname>Arguments</classname> box.
      </para>
      <para>
	<!--cbox(file: command_editor__arguments.png)-->
	The definition of command arguments use the same mechanism as detailed for the
	<literal>Execute on</literal> definition. They can either be left up to the user to
	fill in, when the command is executed or be specified by a filter selectable from the
	dropdown menu. When executed, the <replaceable>num</replaceable> placeholders in the
	command text are replaced by the user specified arguments or the resulting hostlist of
	the filter. There are always as many arguments as there are placeholders in the
	command. To add an argument, edit the command text and add a placeholder there. To
	remove an argument, edit the command text and remove the placeholder.
      </para>
      <para>
	<!--cbox(file: command_editor__testing_command.png)-->
	In the screenshot example, the test command is defined to execute on all head-nodes
	(<systemitem class="systemname">qlu-dev</systemitem> is the only head node in the
	cluster). It has some input and two extra arguments. The first one is fixed to a
	Hostname filter, that evaluates to any host starting with <systemitem
	class="systemname">beo</systemitem>. The second one is left for the user to be
	specified, hence, when executing the command, only the second argument is editable. In
	the screenshot, the <literal>ONLINE</literal> filter was chosen for this argument, but
	any other text would have been possible too. For easy verification, the command text,
	with all the arguments substituted, is shown together with the command input (if
	defined). Note that in the example, the specified input is simply output by the
	<command>cat</command> command, so in the output shown, it appears between the two
	<command>echo</command> commands.
      </para>
    </section>
    <section xml:id="HostFilterEditor">
      <title>Host Filter Editor</title>
      <para>
	<!--cbox(file: filter_editor/main.png)-->
	Host filters define a set of hosts by specifying any number of criteria. The set of
	hosts defined by a filter is dynamic: Changes made to the properties of hosts are
	automatically reflected in the hostlist a filter evaluates to. Every time a filter is
	used, the criteria defining it are evaluated from scratch. Hence, host filters provide
	a powerful tool to classify hosts into groups, in a way that will dynamically take into
	account changes made to the cluster. They can be used in various ways within
	<application>QluMan</application>:
      </para>
      <para>
	<itemizedlist>
	  <listitem>
	    <para>
	      In pre-defined commands, to either specify, the set of hosts, where a command
	      should be executed or to supply the resulting hostlist as an argument to the
	      command.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      As user input for pre-defined or custom commands.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      In the <classname>Enclosure View</classname> to modify the selection.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
      <para>
	<!--cbox(file: filter_editor__select_filter.png)-->
	The filter editor window is split into two areas. At the top the definition of the
	currently selected filter is shown. You can select the filter to be displayed from the
	dropdown menu. At the bottom the hosts that pass all the filters are displayed in the
	compact HostList format. This format is used by a number of other programs including
	pdsh and SLURM (the <link
	xlink:href="https://code.google.com/p/pdsh/wiki/HostListExpressions/___blank___">pdsh
	Wiki</link> has a detailed discussion on the syntax).
      </para>
      <para>
	<!--cbox(file: filter_editor__new3.png)-->
	<!--cbox(file: filter_editor__new2.png)-->
	<!--cbox(file: filter_editor__new.png)-->
	<!--cbox(file: filter_editor__new5.png)-->
	<!--cbox(file: filter_editor__new4.png)-->
      </para>
      <para>
	Select <guimenuitem>new filter</guimenuitem> from the dropdown menu to start defining a
	new filter. Then add filters from the context menu, until the desired subset of hosts
	is displayed in the bottom half of the window. Using their context menu, filters can be
	edited or removed and sub-filters be added. The <guimenuitem>Reset filter</guimenuitem>
	menu item clears the filter, so one can start from scratch. To finally create (save)
	the new filter click <guibutton>Save as</guibutton> and enter a name for it.
      </para>
      <bridgehead xml:id="HostFilterEditorEdit">
	Editing a Filter
      </bridgehead>
      <para>
	Editing a filter is similar to creating a new one. First select the filter from the
	dropdown menu to display it's current definition. Then add, edit or remove individual
	filters as desired. Finally click <guibutton>Save as</guibutton> to save the altered
	filter, Using an existing name will replace the old filter. Using a different name will
	create a new filter.
      </para>
      <bridgehead xml:id="HostFilterEditorFilterTypes">
	Types of Filters
      </bridgehead>
      <para>
	<!--cbox(file: filter_editor__new3.png)-->
	A filter can be added from the context menu (right mouse click) in the top area.  For a
	host to show up in the filtered list (bottom part), it must pass all the filters added.
	Each filter narrows down the list. Any number of filters can be added and they do not
	have to be unique. For example you can add a Hostname filter that selects all hosts
	that begin with <systemitem class="systemname">beo</systemitem> and a Host Template
	filter that selects all <systemitem class="systemname">Demo VM</systemitem> nodes. A
	host has to pass all top-level filters to show up. Currently,
	<application>QluMan</application> provides six top-level filters: Hostname,
	HostTemplate, Enclosure, HEADNODE, HEADNODES and ONLINE. Additional ones will be added
	in future versions.
      </para>
      <blockquote>
	<bridgehead xml:id="HostnameFilter">
	  Hostname Filter
	</bridgehead>
	<para>
	  <!--cbox(file: filter_editor__2_hostnames2.png)-->
	  <!--cbox(file: filter_editor__add__hostname.png)-->
	  <!--cbox(file: filter_editor__2_hostnames1.png)-->
	  Adding a Hostname filter opens up a pop-up dialog asking for the hostname or a
	  regular expression to filter for. The input must be a regular expression in
	  <literal>python</literal> syntax and is matched against the beginning of the
	  hostname. If a match against the full hostname is desired then "$" should be added at
	  the end. A ".*" can be added to the front, to match anywhere in the hostname instead
	  of matching against the beginning.
	</para>
	<para>
	  Multiple hostname patterns can be added to a Hostname filter through the context
	  menu. 
	  <note>
	    <para>
	      Note that this is <emphasis role="bold">additive</emphasis>: If a host matches at
	      least one pattern, it will be included in the resulting list.
	    </para>
	  </note>
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="HostTemplateFilter">
	  Host Template Filter
	</bridgehead>
	<para>
	  <!--cbox(file: filter_editor__hotstemplate__add_template1.png)-->
	  <!--cbox(file: filter_editor__hotstemplate.png)-->
	  <!--cbox(file: filter_editor__add_hosttemplate.png)-->
	  <!--cbox(file: filter_editor__hotstemplate2.png)-->
	  <!--cbox(file: filter_editor__hotstemplate__add_template2.png)-->
	  Adding a Host Template filter does not pop up a dialog. Instead it adds an empty Host
	  Template filter. This simply selects all hosts with an assigned Host Template. Hosts
	  that do not have a Host Template will not pass this filter. The filter can be made
	  more specific by adding Host Template patterns to it through the context menu. This
	  opens up a pop-up dialog, from where an existing Host Template name can be selected.
	</para>
	<para>
	  The result is a list of hosts, for which the associated Host Template matches the
	  given pattern.  Adding multiple Host Template names is again additive, just like with
	  Hostname patterns.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="EnclosureFilter">
	  Enclosure Filter
	</bridgehead>
	<para>
	  <!--cbox(file: filter_editor__enclosure.png)-->
	  <!--cbox(file: filter_editor__add__enclosure.png)-->
	  <!--cbox(file: filter_editor__enclosure2.png)-->
	  <!--cbox(file: filter_editor__enclosure__add.png)-->
	  Adding an Enclosure filter also does not bring up a dialog. Like a Host Template
	  filter, it selects all hosts that are part of an enclosure. Unlike the Hostname and
	  Host Template filters though, an Enclosure filter allows for two different
	  specifications: The name <emphasis role="bold">and</emphasis> the type of an
	  enclosure can be matched. Just like Hostname and Host Template filters the Enclosure
	  filter is additive. Adding sub-filters for both the Enclosure name and the Enclosure
	  type will filter hosts that match at least one of those criteria. To filter for hosts
	  that match both, an Enclosure name and an Enclosure type two separate Enclosure
	  filters have to be used, to get the intersection of both filters. The first one to
	  filter the name and the second to filter the type.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="Inverting-a-Filter">
	  Inverting a Filter
	</bridgehead>
	<para>
	  Every filter, sub-filter and pattern can be inverted through the context menu. The
	  context menu for a pattern contains menu entries for both the pattern and the
	  enclosing filter separated by a line. The first <emphasis
	  role="bold">Invert</emphasis> entry will invert the specific pattern that was
	  selected, while the second <emphasis role="bold">Invert</emphasis> will invert the
	  whole filter.
	</para>
	<para>
	  <!--cbox(file: filter_editor__invert_filter.png)-->
	  <!--cbox(file: filter_editor__invert_pattern.png)-->
	  <!--cbox(file: filter_editor__invert.png)-->
	  Besides the obvious, this can also be useful in finding hosts that are not configured
	  correctly. For example, adding an empty Host Template filter and inverting it, will
	  show all hosts without a Host Template. Adding a second filter, that selects all
	  switches, power controllers and other special devices (they usually don't need a Host
	  Template) and also inverting that, results in a list of all hosts, that are neither
	  properly configured nodes (missing Host Template) nor special devices.
	</para>
      </blockquote>
      <blockquote>
	<bridgehead xml:id="Additive-versus-Subtractive">
	  Additive versus subtractive
	</bridgehead>
	<para>
	  <!--cbox(file: filter_editor__subtractive.png)-->
	  When constructing a filter, it is important to remember, that all top-level filters
	  are subtractive. A host must pass all top-level filters to show up in the result. On
	  the other hand, all patterns and sub-filters are additive. Matching any one of them
	  within a top-level filter adds the host to the result of that filter. Hence, when
	  subtractive behavior is desired for patterns or sub-filters, each pattern or
	  sub-filter must be added to its own top-level filter. For example, to select all
	  hosts that start with <systemitem class="systemname">beo</systemitem> as well as end
	  on "1" two Hostname filters have to be added.
	</para>
      </blockquote>
    </section>
    <section xml:id="User-Rights-Manage">
      <title>QluMan User and Rights Management</title>
      <para>
	<application>QluMan</application> is <literal>multi-user capable</literal> and provides
	an interface to configure and control users as well as their permissions when they work
	with <application>QluMan</application>. The <application>QluMan</application> users are
	not connected to system users in any way. To simplify permission management, the
	concept of <literal>user roles</literal> can be used. User roles allow to predefine a
	<emphasis role="bold">collection of permissions</emphasis> for
	<application>QluMan</application> operations. Once defined, they can be assigned to a
	user.
      </para>
      <section xml:id="sec-User-Manage">
	<title>Managing QluMan Users</title>
	<para>
	  <!--cbox(file: users/main.png)-->
	  <!--cbox(file: users__select.png)-->
	  The <literal>admin user</literal> is pre-defined and has the <literal>admin
	  role</literal>, meaning all possible rights. Roles for the admin user can not be
	  changed, just like the root user in a Linux system always has all rights. When
	  running <application>QluMan</application> for the first time, you should set the
	  correct email address for the admin user.
	</para>
	<para>
	  <!--cbox(file: users__new3.png)-->
	  <!--cbox(file: users__new2.png)-->
	  <!--cbox(file: users__select.png)-->
	  <!--cbox(file: users__new.png)-->
	  To create a new user, click <guibutton>New User</guibutton> and enter the name for
	  the new user to create it. Then select the user from the drop-down menu and fill out
	  the remaining fields. The changes will be saved automatically when
	  <keycap>return</keycap> is pressed or the input field looses the focus. New users
	  have no roles assigned to them and will have no rights to change anything. They can
	  look but not touch. See <xref linkend="sec-Permission-Manage"
	  endterm="sec-Permission-Manage"/> for how to create new roles and assign them to the
	  user by checking the respective checkboxes. If the <guibutton>New User</guibutton>
	  button is not selectable then the user lacks sufficient rights to create new
	  users. The roles buttons will then also be disabled preventing an unauthorized user
	  to give himself or others extra roles.
	</para>
	<para xml:id="para-one-time-token">
	  <!--cbox(file: users__new_auth_token.png)-->
	  The new is also created without login credentials, so initially, he can't log
	  in. Hence, the next step is to generate a one-time token for the user by clicking
	  <guibutton>New Auth Token</guibutton>.  Generating the one-time token may take a
	  little to generate while before the <classname>New Auth Token</classname> dialog
	  opens and shows a certificate containing the generated one-time token as well as the
	  other login informations required to connect to the server. The certificate is
	  protected by an 8 digit password so that it can be transfered over unencrypted
	  communications channels like email or jabber. In such a case the password should be
	  send over a second, different, communication channel, e.g. read over the phone. As a
	  special case, when a user clicks <guibutton>New Auth Token</guibutton> for itself,
	  the generated token is imported into the running client and replaces the current
	  login credentials. A reconnect is then triggered forcing the client to generate a new
	  random public/private key pair and use the one-time token to authenticate itself to
	  the server. This should be used to invalidate the old keys and replace them with
	  fresh ones when a user suspects the certificate safe might have been compromised by
	  an attacker.
	</para>
	<para>
	  <!--cbox(file: users__new_auth_token_2.png)-->
	  The <classname>New Auth Token</classname> dialog also has 3 usefull buttons at the
	  right bottom corner. The <guibutton>Import</guibutton> button allows adding the
	  certificate directly to the running client. The use case for this is when creating a
	  user account for oneself when working as admin. It is recommendd that for clusters
	  with multiple users with admin role that every user has their own user account and
	  the admin user is only used to create those.
	  <!--cbox(file: users__new_auth_token__mailed.png)-->
	  <!--cbox(file: users__new_auth_token__saved.png)-->
	  The <guibutton>Save</guibutton> button allows saving the certificate into a file and
	  the <guibutton>Mail</guibutton> button sends the certificate to the email configured
	  for the user. In both cases only the certificate is saved or mailed and the password
	  needs to be send separately.
	</para>
	<para>
	  For the best security it is recommened to leave any new user without roles until they
	  have logged in using the one-time token. That way if the certificate was intercepted
	  it has become useless to an attacker. Or if the attacker manages to intercept and use
	  the certificate before the real user then the real user won't be able to use
	  it. Meanwhile the attacker won't be able to change anything in the cluster.
	</para>
	<note>
	  <para>
	    The certificate contains the information about the cluster telling the client how
	    to connect to it and the public key of the <systemitem
	    class="systemname">qlumand</systemitem> server that ensures the client will only
	    talk to the right server and can't be eavesdropped. It also contains a one-time
	    token allowing any client to log in exactly once within the next 48 hours. On the
	    first login with a correct one-time token the clients public key (generated
	    randomly and unique to use cluser and user) is stored by the server and used to
	    authenticate the user in the future. The clients and servers public and private
	    keys are also used when connecting to safely exchange session keys for encryption
	    with perfect forward security.
	  </para>
	</note>
	<para>
	  <!--cbox(file: users__delete2.png>-->
	  <!--cbox(file: users__delete.png>-->
	  An user other than admin can be deleted by clicking the <guibutton>Delete
	  User</guibutton> button. Just like the <guibutton>New User</guibutton> button it is
	  only enabled if the current user has sufficient rights.
	</para>
      </section>
      <section xml:id="sec-Permission-Manage">
	<title>Managing User Roles/Permissions</title>
	<para>
	  The <application>QluMan</application> server performs <emphasis role="bold">many
	  individual rights</emphasis> checks, before it allows/performs an operation. Many of
	  those correspond directly to a specific window in the GUI, giving the user the right
	  to alter settings in that window. For example, the right to configure UnionFS groups
	  corresponds directly to operations available from the <literal>UnionFS
	  Groups</literal> window under <guimenuitem>Manage
	  Configs</guimenuitem>-><guimenuitem>UnionFS Groups</guimenuitem>. Others govern the
	  right to specific actions or to alter specific properties. For example, the right to
	  configure OpenSM on hosts enables the user to add, alter or delete the
	  <literal>OpenSM Ports</literal> and <literal>OpenSM Options</literal> property of
	  hosts in the <classname>Enclosure View</classname>.
	</para>
	<para>
	  The rights are grouped into 4 categories: <literal>Admin rights</literal> covers
	  rights with global impact and root access to nodes, <literal>Booting</literal> covers
	  all settings that affect how nodes will boot, <literal>Services</literal> covers the
	  configuration of daemons and <literal>Host Config</literal> covers the general
	  configuration of hosts.
	</para>
	<para>
	  <!--cbox(file: roles__manager.png)-->
	  <!--cbox(file: roles__new.png)-->
	  <!--cbox(file: roles__empty.png)-->
	  Creating and editing roles is simple. Click <guibutton>New</guibutton> to create a
	  new role, fill in a name and description for it and click
	  <guibutton>OK</guibutton>. To change the rights associated with a role, first select
	  it using the dropdown menu at the top. Next click the checkmark boxes to the left of
	  the rights you want to change, grant or remove from the role. Click
	  <guibutton>Save</guibutton> to save the changes or <guibutton>>Undo</guibutton> to
	  reset the rights to the last saved settings.
	</para>
      </section>
    </section>
    <section xml:id="Look-And-Feel">
      <title>Customizing the Look&amp;Feel</title>
      <para>
	There are three aspects of <application>QluMan's</application> appearance that can be
	customized: Fonts, colors and widget style. Since QluMan is a QT application, it's
	Look&amp;Feel can be controlled with <link
	xlink:href="http://www.kde.org/___blank___">KDE</link> tools. Select the
	<guimenuitem>Manage Cluster->Preferences</guimenuitem> menu entry to bring up the KDE
	<classname>System Settings</classname> dialog. Now click on the <classname>Application
	Appearance</classname> icon and you'll have the options to modify fonts, colors and
	style.
      </para>
      <bridgehead xml:id="Look-And-Feel-Fonts">
	Fonts
      </bridgehead>
      <para>
	When you click on the <guiicon>Fonts</guiicon> icon, you'll see a list of different
	font identifiers for which you can change the font settings.  The relevant identifiers
	to be adjusted for <application>QluMan</application> are <literal>General</literal>,
	<literal>Menu</literal> and <literal>Window Title</literal>. Changing one of the values
	and clicking the <guibutton>Apply</guibutton> button changes the corresponding font on
	the fly.
      </para>
      <bridgehead xml:id="Look-And-Feel-Colors">
	Colors
      </bridgehead>
      <para>
	<!--cbox(file: look-and-feel/system_settings_colors.png)-->
	Click on the <guiicon>Colors</guiicon> icon and choose the
	<guimenuitem>Colors</guimenuitem> tab. There you can adjust the color of the different
	elements of the <application>QluMan GUI</application>. You can narrow down the color
	identifiers to the ones affecting particular GUI elements by choosing a specific color
	set with the corresponding pull-down menu. Changing one of the values and clicking the
	<guibutton>Apply</guibutton> button changes the corresponding color on the fly.
      </para>
      <bridgehead xml:id="Look-And-Feel-Manual">
	Manual
      </bridgehead>
      <para>
	If you're using <firstterm>KDE4</firstterm> on you're desktop, instead of configuring
	using the <classname>System Settings</classname> dialog, you can also move
	<filename>/root/.kde/share/config</filename> to
	<filename>/root/.kde/share/config.bak</filename> and copy your personal configured
	<filename>.kde/share/config</filename> directory to
	<filename>/root/.kde/share</filename>. As long as you're not using any non-standard KDE
	themes, this should just apply the favorite desktop settings you're familiar with to
	<application>QluMan</application> (restart of QluMan GUI required).
      </para>
      <bridgehead xml:id="Look-And-Feel-Widget-Style">
	Widget Style
      </bridgehead>
      <para>
	<!--cbox(file: look-and-feel/qtconfig.png)-->
	Changing the widget style can be a little more involved. First you need to start the QT
	configurator <application>qtconfig</application> and choose a GUI style (default is
	QtCurve). The following assumes you're running <application>qluman-qt</application> on
	the head- or FE node. In case you have it installed on your workstation, just execute
	<application>qtconfig</application> there.
	<screen>
<prompt>0 user@workstation ~ $</prompt>
<command>ssh -X root@servername qtconfig</command>
	</screen>
      </para>
      <para>
	When you're done, select
	<guimenuitem>File</guimenuitem>-><guimenuitem>Save</guimenuitem> and you'll already see
	the changes. After this you can exit qtconfig. If you want further customization of the
	widget style (note that only some styles are configurable, among them QtCurve), you can
	now go back to the <classname>Application Appearance</classname> Dialog (see above),
	click on the <guiicon>Style</guiicon> icon, choose the
	<!--cbox(file: look-and-feel/system_settings_style.png)-->
	style you've selected in qtconfig as <literal>Widget style</literal> and press the
	<guibutton>Configure...</guibutton> button. You'll see a large number of options for
	customization. When you're satisfied with your modifications, press the
	<guibutton>OK</guibutton> button and finally the <guibutton>Apply</guibutton> button of
	the <classname>Style - System Settings</classname> window. Note, that you will see the
	resulting changes only after performing some actions (pressing a button, etc.)  in the
	<application>QluMan GUI</application>.
      </para>
      <para>
	To have more options for changing the widget style from the default of QtCurve, you can
	install additional kde-style packages (.e.g <package>kde-style-oxygen</package>) on the
	machine, where you're executing the <application>QluMan GUI</application>.
      </para>
    </section>
  </chapter>
  <xi:include href="Revision_History.xml"/>
  <index />
</book>
